<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: src/c/collector.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('collector_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">collector.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bvm_8h_source.html">../h/bvm.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec53adbe33268c8a6d6b7228fab8770f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#aec53adbe33268c8a6d6b7228fab8770f">gc_mark_debug_roots</a> ()</td></tr>
<tr class="separator:aec53adbe33268c8a6d6b7228fab8770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0566ef5a051000ecf595d9e7a4f9aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#a7d0566ef5a051000ecf595d9e7a4f9aa">bvm_gc</a> ()</td></tr>
<tr class="separator:a7d0566ef5a051000ecf595d9e7a4f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7f645f124f36431c9b2096a3f5f0a6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#a7f645f124f36431c9b2096a3f5f0a6b8">bvm_gl_gc_permanent_roots</a> = NULL</td></tr>
<tr class="separator:a7f645f124f36431c9b2096a3f5f0a6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5129f1bc5fb7865f91bcb9e93da77c9"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#ac5129f1bc5fb7865f91bcb9e93da77c9">bvm_gl_gc_permanent_roots_top</a></td></tr>
<tr class="separator:ac5129f1bc5fb7865f91bcb9e93da77c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b49d12a9eed2d3b462aa3a1dbc445e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#af4b49d12a9eed2d3b462aa3a1dbc445e">bvm_gl_gc_transient_roots</a> = NULL</td></tr>
<tr class="separator:af4b49d12a9eed2d3b462aa3a1dbc445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7924db7f44f97f354770dbf8d7e629"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#a3f7924db7f44f97f354770dbf8d7e629">bvm_gl_gc_transient_roots_top</a></td></tr>
<tr class="separator:a3f7924db7f44f97f354770dbf8d7e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0274ebf090cc66acc0548b69ef7aa7a1"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#a0274ebf090cc66acc0548b69ef7aa7a1">bvm_gl_gc_transient_roots_depth</a> = <a class="el" href="define_8h.html#a754283c0856871a0e1f81f5a639f3ea2">BVM_GC_TRANSIENT_ROOTS_DEPTH</a></td></tr>
<tr class="separator:a0274ebf090cc66acc0548b69ef7aa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275bea922b95075ad41806d5d7f6f3a9"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="collector_8c.html#a275bea922b95075ad41806d5d7f6f3a9">bvm_gl_gc_permanent_roots_depth</a> = <a class="el" href="define_8h.html#a493d5652046906b14b799817c9e62d3d">BVM_GC_PERMANENT_ROOTS_DEPTH</a></td></tr>
<tr class="separator:a275bea922b95075ad41806d5d7f6f3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Garbage Collector.</p>
<h1><a class="anchor" id="ov"></a>
Overview</h1>
<p>The collector is implemented as a mark-and-sweep collector. Tri-colour marking is used to keep the door open for a later implementation of incremental GC.</p>
<p>Nothing controversial about the algorithm in use. The first stage recursively marks each known root heap chunk and its children and then the heap is swept to free those chunks that were not marked.</p>
<p>The allocator marks each chuck <a class="el" href="heap_8h.html#a11f1d11599c4fddcc0d3fe1017e0a7d9">BVM_GC_COLOUR_WHITE</a> as it created. During GC, as each memory structure is scanned it is marked <a class="el" href="heap_8h.html#a2cf91d594223471231b4400b42a5b778">BVM_GC_COLOUR_GREY</a> to note it is in-progress, then finally it is marked <a class="el" href="heap_8h.html#a7ddbb155916ceb6ddf97047051d7cef5">BVM_GC_COLOUR_BLACK</a>.</p>
<p>After all scanning, the heap is traversed and anything still marked as <a class="el" href="heap_8h.html#a11f1d11599c4fddcc0d3fe1017e0a7d9">BVM_GC_COLOUR_WHITE</a> that is not in the free list is freed. Everything else gets remarked as <a class="el" href="heap_8h.html#a11f1d11599c4fddcc0d3fe1017e0a7d9">BVM_GC_COLOUR_WHITE</a>.</p>
<p>This collector will also collect unused classes.</p>
<p>The collector knows how to scan a chunk for children by using the "allocation type" that the chunk was created with. Alloc types define the structure and usage of each chunk. Alloc types are used for no other purpose than to help the collector scan a chunk when marking it - to identify any other heap references it may contain.</p>
<p>Alloc types are one of only a few touch points the collector has with the allocator. Others are the colours used when marking chunks during collection, and the usage of the <a class="el" href="heap_8c.html#a01af772fb247fd5ab4e6bf8ebfcd5e8d">bvm_heap_free()</a> function. Of course, the allocator will call the <a class="el" href="collector_8c.html#a7d0566ef5a051000ecf595d9e7a4f9aa">bvm_gc()</a> function when memory is exhausted.</p>
<p>The collector and the allocator are designed to be quite separate. The allocator supports 2 bits to specify GC colours and 4 bits for the allocation type. The usage of these colours and allocation types is up to the implementation of the collector.</p>
<h1><a class="anchor" id="roots"></a>
Stack, Permanent and Transient Roots</h1>
<p>The set of known roots is established from three sources. The Thread Stacks, and the Permanent and Transient stacks.</p>
<p>The thread stacks are marked by traversing and inspecting the locals and opstack area for each frame in the stack. Each cell in that frame locals/opstack range is tested to see if it is a valid pointer into the heap, and if so it is considered a root and is recursively marked. Stack data is reused so it could have junk in it from a previous usage - hence the 'test to see if it is a valid pointer'.</p>
<p>The other two root sources, the transient and permanent root stack, are slightly different. Each is also a stack, albeit far simpler than a thread stack. Each of these stacks has an associated counter to mark the current top of the stack.</p>
<h2><a class="anchor" id="proots"></a>
Permanent Roots</h2>
<p>For permanent heap roots. Quite simply, when the VM consumes some heap for that it knows will never be freed it pushes it onto the permanent stack using the <a class="el" href="collector_8h.html#add1814d3fa23ba89ad3233ebfb15de19">BVM_MAKE_PERMANENT_ROOT</a> macro. For example, as bootstrap classes are loaded they are pushed onto the permanent stack. Same for a few objects such as the pre-built "out of memory" exception object. The permanent root stack never shrinks. The purists of you out there would notice the lack of a 'pop' facility and probably argue it is not actually a stack - but go fly a kite.</p>
<p>The collector considers all entries in the permanent stack below the top as roots. They will be marked and scanned and will not be freed.</p>
<h2><a class="anchor" id="troots"></a>
Transient Roots</h2>
<p>Keeping track of transient roots is more complicated. Transient roots exist only during a 'transient' block of execution. Transient roots are the answer to the rather complicated question of using heap memory and not having the GC clean it up before it is associated with a root or the VM has finished using it. The danger occurs when the VM allocs some memory, then allocs some more before being finished with the first. For example, when creating a String the memory for the string object is alloc'd, then moments later the memory for its char[] object is also alloc'd).</p>
<p>Any alloc may potentially cause a GC. In this case, without some means of keeping the string object memory from being GC'd, the char[] allocation may cause the string memory to be freed. After all, the memory is not associated with any root as yet - the GC occurs in 'mid-stoke'. The VM needs some way of stopping the collector from freeing the string memory until such time as the VM has either associated it with a root, or if were a temporary alloc, is happy to have it freed.</p>
<p>The transient stack is the solution. The transient stack is like the permanent stack except that it can shrink. The collector considers all entries in the transient stack below the top as roots. They will be marked and scanned and will not be freed.</p>
<p>There is also no 'pop' facility but this is handled by the 'transient block' mechanism.</p>
<p>The <a class="el" href="collector_8h.html#a7b159468319fec5cb4965ab5f0435acb">BVM_BEGIN_TRANSIENT_BLOCK</a> macro marks the start of a block that may contain some transient roots. The <a class="el" href="collector_8h.html#a6c1d6c08dc0ecb98babacb93416343b7">BVM_END_TRANSIENT_BLOCK</a> marks the end of the block. When a transient block is entered using <a class="el" href="collector_8h.html#a7b159468319fec5cb4965ab5f0435acb">BVM_BEGIN_TRANSIENT_BLOCK</a>, the macro records the current top of the transient stack. Inside the transient block any memory received from alloc() that is to be transiently protected from GC is placed on the stack using the <a class="el" href="collector_8h.html#a14504e728cc933649537afae1e6d7736">BVM_MAKE_TRANSIENT_ROOT</a> macro - this macro effectively 'pushes' the root onto the transient stack - the top goes up.</p>
<p>The collector considers anything below the top of the transient stack as being a root and is marked and scanned during GC. As the transient block is exited (at <a class="el" href="collector_8h.html#a6c1d6c08dc0ecb98babacb93416343b7">BVM_END_TRANSIENT_BLOCK</a>) the transient stack top is restored to where it was on entry to the transient block. In effect, this 'pops' all those transient roots that occurred in the transient block and therefore they will become eligible for collection - unless they can be reached by some other means (like being stored in a method local variable in a thread stack).</p>
<p>Transient blocks may be nested (and normally are) as VM functions call each other.</p>
<p>The BVM_TRY/BVM_CATCH mechanism also creates a transient stack mark for itself. If an exception is caught or the BVM_TRY/BVM_CATCH exits normally, the top of the transient stack is restored in the same way as exiting a transient block defined by BEGIN/BVM_END_TRANSIENT_BLOCK does. This has the effect of restoring the top of the stack regardless of the BEGIN/END_TRANSIENT_BLOCKS that occurred within the scope of the BVM_TRY/BVM_CATCH.</p>
<h1><a class="anchor" id="cm"></a>
Chunk Marking</h1>
<p>All heap chunks are subject to collection except those of <a class="el" href="collector_8h.html#a18a8e77daa8a6efa343cf1ad8c49b696">BVM_ALLOC_TYPE_STATIC</a>. Static chunks are ignored by the collector.</p>
<p>Each alloc type has its own structure and the collector marker is effectively a switch on the alloc type - with subsequent processing for each type. The types are designed to make life easy for the marker. For example, rather than having all objects alloc'd as <a class="el" href="collector_8h.html#abffe02bbdbedac03aa667ce61a5f1b2f">BVM_ALLOC_TYPE_OBJECT</a> which implies scanning for fields, there are others such as <a class="el" href="collector_8h.html#a2e744b6d54dc73ddd35401c87065ad7e">BVM_ALLOC_TYPE_ARRAY_OF_PRIMITIVE</a> which has no fields and can be marked very quickly.</p>
<p>The collector will also collect unused clazz structures and all associated methods and fields and constants and so on. If a classloader object becomes unreachable, this will cause the collector to free its managed Class objects and also clazz structures for that classloader. Just like the JVMS says it should. All elements of a loaded class are loaded as STATIC, except for the actual clazz structure itself. In this way, there is no need to constantly be scanning clazz structures and all their stuff. The things that make up a class are never eligible for collection (because they are STATIC). But, when the Class object is, and then it associated <code>bvm_clazz_t</code> also is, and the collector takes special action and whips around to all the memory used by the clazz and frees it.</p>
<p>It is important to note that interned String constants and pooled UTF strings for a clazz will NOT be freed when the clazz that they came from is freed. Once a string is interned or a utf string pooled, it is there for the lifetime of the executing VM.</p>
<h1><a class="anchor" id="bvm_gc-cm"></a>
Weak References</h1>
<p>Weak references are supported in the same manner as CLDC 1.1. CLDC 1.1 Weak references support is limited to the <code>java.lang.ref.WeakReference</code> class - there are no notification queues, nor are there different type of references - just 'weak'.</p>
<p>The <a class="el" href="collector_8h.html#aecb4bb66a3da89b4c2572919fad054b7">BVM_ALLOC_TYPE_WEAK_REFERENCE</a> denotes a weak reference object. As a weak reference object is created the native method <a class="el" href="native_8c.html#ac95924aece557be13855a5acd95da362">java_lang_ref_WeakReference_makeweak</a> changes the heap alloc type from <a class="el" href="collector_8h.html#abffe02bbdbedac03aa667ce61a5f1b2f">BVM_ALLOC_TYPE_OBJECT</a> to <a class="el" href="collector_8h.html#aecb4bb66a3da89b4c2572919fad054b7">BVM_ALLOC_TYPE_WEAK_REFERENCE</a>.</p>
<p>Each GC cycle maintains a list of encountered WeakReference objects. When the marking phase encounters a weak reference object, the marker adds the object to the head of the list of weak objects.</p>
<p>After the marking phase is complete - and before the sweep, the list of weak reference objects is traversed. If a 'referent' object that a weak reference object points to is going to be swept in this GC cycle, the referent object field of the weak reference object is set to <code>NULL</code>. Simple.</p>
<h1><a class="anchor" id="future"></a>
Future notes:</h1>
<p>The current algorithm does not limit recursion depth so, in theory, it could crash the VM if it does not have enough 'C' stack space. This is bad. The collector really ought to be able to make it way through a collection without the possibility of crashing the VM. Perhaps the same collection could be used to limit the recursion depth by stopping recursion at a given level.</p>
<dl class="section author"><dt>Author</dt><dd>Greg McCreath </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.0.10 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7d0566ef5a051000ecf595d9e7a4f9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0566ef5a051000ecf595d9e7a4f9aa">&#9670;&nbsp;</a></span>bvm_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_gc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a garbage collection cycle. A detailed explanation is at the top of this source file. </p>

</div>
</div>
<a id="aec53adbe33268c8a6d6b7228fab8770f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec53adbe33268c8a6d6b7228fab8770f">&#9670;&nbsp;</a></span>gc_mark_debug_roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gc_mark_debug_roots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark objects in the JDWP debugger root map. Objects in this map have put there as a consequence of the JDWP command ObjectReference.DisableCollection. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7f645f124f36431c9b2096a3f5f0a6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f645f124f36431c9b2096a3f5f0a6b8">&#9670;&nbsp;</a></span>bvm_gl_gc_permanent_roots</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a>* bvm_gl_gc_permanent_roots = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The permanent roots stack </p>

</div>
</div>
<a id="a275bea922b95075ad41806d5d7f6f3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275bea922b95075ad41806d5d7f6f3a9">&#9670;&nbsp;</a></span>bvm_gl_gc_permanent_roots_depth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_gc_permanent_roots_depth = <a class="el" href="define_8h.html#a493d5652046906b14b799817c9e62d3d">BVM_GC_PERMANENT_ROOTS_DEPTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The permanent root stack depth (actual depth, not in BVM_KB). Defaults to <a class="el" href="define_8h.html#a493d5652046906b14b799817c9e62d3d">BVM_GC_PERMANENT_ROOTS_DEPTH</a>. </p>

</div>
</div>
<a id="ac5129f1bc5fb7865f91bcb9e93da77c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5129f1bc5fb7865f91bcb9e93da77c9">&#9670;&nbsp;</a></span>bvm_gl_gc_permanent_roots_top</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_gc_permanent_roots_top</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The current top of the permanent root stack </p>

</div>
</div>
<a id="af4b49d12a9eed2d3b462aa3a1dbc445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b49d12a9eed2d3b462aa3a1dbc445e">&#9670;&nbsp;</a></span>bvm_gl_gc_transient_roots</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a>* bvm_gl_gc_transient_roots = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The transient roots stack </p>

</div>
</div>
<a id="a0274ebf090cc66acc0548b69ef7aa7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0274ebf090cc66acc0548b69ef7aa7a1">&#9670;&nbsp;</a></span>bvm_gl_gc_transient_roots_depth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_gc_transient_roots_depth = <a class="el" href="define_8h.html#a754283c0856871a0e1f81f5a639f3ea2">BVM_GC_TRANSIENT_ROOTS_DEPTH</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default transient root stack depth (actual depth, not in BVM_KB). Defaults to <a class="el" href="define_8h.html#a754283c0856871a0e1f81f5a639f3ea2">BVM_GC_TRANSIENT_ROOTS_DEPTH</a>. </p>

</div>
</div>
<a id="a3f7924db7f44f97f354770dbf8d7e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7924db7f44f97f354770dbf8d7e629">&#9670;&nbsp;</a></span>bvm_gl_gc_transient_roots_top</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_gc_transient_roots_top</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The current top of the transient root stack </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3b19ecf29356981f494745fbef7e56bf.html">c</a></li><li class="navelem"><a class="el" href="collector_8c.html">collector.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
