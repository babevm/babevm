<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: src/c/heap.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('heap_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">heap.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bvm_8h_source.html">../h/bvm.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe49028dcdf54023add0e2fedcc546a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#abe49028dcdf54023add0e2fedcc546a7">bvm_heap_is_chunk_valid</a> (<a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *chunk)</td></tr>
<tr class="separator:abe49028dcdf54023add0e2fedcc546a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b131ac3462e75acebe769bdcf44e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a60b131ac3462e75acebe769bdcf44e8b">bvm_heap_free_chunk</a> (<a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *chunk)</td></tr>
<tr class="separator:a60b131ac3462e75acebe769bdcf44e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f20525b662e5f325a82c9d671bd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#acc9f20525b662e5f325a82c9d671bd32">bvm_heap_init</a> (size_t size)</td></tr>
<tr class="separator:acc9f20525b662e5f325a82c9d671bd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651a07cdaf98eac5b157a98de7c2501c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> (size_t size, int alloc_type)</td></tr>
<tr class="separator:a651a07cdaf98eac5b157a98de7c2501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e1b325c892f999261c83fd7b1d9c0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a> (size_t size, int alloc_type)</td></tr>
<tr class="separator:a097e1b325c892f999261c83fd7b1d9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebde1065baed2244a7a0b553ce3ff7d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a7ebde1065baed2244a7a0b553ce3ff7d">bvm_heap_clone</a> (void *ptr)</td></tr>
<tr class="separator:a7ebde1065baed2244a7a0b553ce3ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba620266351957528daaf88ac26d3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a3ba620266351957528daaf88ac26d3b2">bvm_heap_set_alloc_type</a> (void *ptr, int alloc_type)</td></tr>
<tr class="separator:a3ba620266351957528daaf88ac26d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01af772fb247fd5ab4e6bf8ebfcd5e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a01af772fb247fd5ab4e6bf8ebfcd5e8d">bvm_heap_free</a> (void *ptr)</td></tr>
<tr class="separator:a01af772fb247fd5ab4e6bf8ebfcd5e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31127351be375d2cf70054e3fc160737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a31127351be375d2cf70054e3fc160737">bvm_heap_release</a> ()</td></tr>
<tr class="separator:a31127351be375d2cf70054e3fc160737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b6d04e5ec12b677b478fa9336a38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a487b6d04e5ec12b677b478fa9336a38a">bvm_heap_debug_dump</a> ()</td></tr>
<tr class="separator:a487b6d04e5ec12b677b478fa9336a38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569b93dc7870e12999ff2f34cf2b992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#ae569b93dc7870e12999ff2f34cf2b992">printFreeChunk</a> (<a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *chunk)</td></tr>
<tr class="separator:ae569b93dc7870e12999ff2f34cf2b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439c0145a0d4ce11861133a66dcf3d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a439c0145a0d4ce11861133a66dcf3d0f">bvm_heap_debug_dump_free_list</a> ()</td></tr>
<tr class="separator:a439c0145a0d4ce11861133a66dcf3d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4fe5b937b911a670d0cadb34874327f5"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a4fe5b937b911a670d0cadb34874327f5">bvm_gl_heap_start</a></td></tr>
<tr class="separator:a4fe5b937b911a670d0cadb34874327f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe901f5fd558757c72828199f98e242e"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#afe901f5fd558757c72828199f98e242e">bvm_gl_heap_end</a></td></tr>
<tr class="separator:afe901f5fd558757c72828199f98e242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932e76c0c10c17f1cced691109716c84"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a932e76c0c10c17f1cced691109716c84">bvm_gl_heap_free</a></td></tr>
<tr class="separator:a932e76c0c10c17f1cced691109716c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c4b6068de2f551dfe1bb23be6703d2"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="heap_8c.html#a45c4b6068de2f551dfe1bb23be6703d2">bvm_gl_heap_size</a> = <a class="el" href="define_8h.html#ace404562cc20b9250e9e430e6844371a">BVM_HEAP_SIZE</a></td></tr>
<tr class="separator:a45c4b6068de2f551dfe1bb23be6703d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>VM heap management (alloc/free)</p>
<dl class="section author"><dt>Author</dt><dd>Greg McCreath </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.0.10</dd></dl>
<h1><a class="anchor" id="ov"></a>
Overview</h1>
<p>The allocator serves the VM by maintaining the heap. The heap is a contiguous pool of memory taken from the host OS when the VM is initialised. The size of the heap is static and does not grow or shrink during VM execution.</p>
<p>The allocator provides the ability for the VM to request some dynamic memory from the heap and also to put it back.</p>
<p>This allocator could be described as a "coalescing best-fit" allocator. It uses a two-way list of free space within the heap to quickly find a memory chunk of a given size using <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc()</a>. When memory is given back to the allocator using <a class="el" href="heap_8c.html#a01af772fb247fd5ab4e6bf8ebfcd5e8d">bvm_heap_free()</a> the memory is coalesced with neighbouring chunks free chunks - if any.</p>
<p>Each allocated 'chunk' of memory has a 4 byte header associated with it. The minimum chunk size is those 4 bytes + 3 pointers sizes - so for 32 bit, it is 16 bytes, and for 64 is 32 - when 8 byte alignment is taken into account. Requesting <code>bvm_heap_alloc(0)</code> will still allocate the minimum bytes. The extra 3 pointers are using for housekeeping when the chunk is free (we'll get to that) - but are not used when the chunk is in use. So for (say 32 bit) requesting <code>bvm_heap_alloc(12)</code> will still consume just those 16 bytes. There is a min size - but it is not all overhead.</p>
<p>Chunks can be thought of as either 'free' or 'in use'. Free chunks will have a reference to them in the 'free list'. The free list is a two-way linked list of 'free' chunks sorted in size order. Smallest free chunks at the front, largest at the end. When allocating the list is scanned in smallest-to-largest fashion looking for a free chunk that will accommodate the requested size.</p>
<p>When memory is requested using <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> or <a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a> a memory 'allocation type' is specified. The allocator does nothing with the allocation type except place it into the chunk header. The allocation type is used by the garbage collector to determine how to traverse the chunk memory looking for other memory references.</p>
<p>Each requested chunk of memory is marked a <a class="el" href="heap_8h.html#a11f1d11599c4fddcc0d3fe1017e0a7d9">BVM_GC_COLOUR_WHITE</a> as the start point for the garbage collector. More documentation is in <a class="el" href="collector_8c.html">collector.c</a>.</p>
<p>Some important things to note:</p>
<p>The heap is static. Once a chunk has been allocated it does not move when it is in use. When it is freed it may remain where it is, or if it is coalesced into a larger free chunk it will be merged into that larger chunk. But it will be remain in the same location. The heap is central to the VM. All dynamic memory usage is controlled by the heap. There are only a few places where the VM asks the host OS for memory - this is the main one - to establish the heap managed by this allocator. Some sanity checking is undertaken when freeing memory. A freed chunk cannot be re-freed for example. A chunk whose address is beyond the bounds of the heap is an obvious error. A few more also.</p>
<p>Although free chunks and in-use chunks both consume same bytes their internal structure is different depending on their free/in-use state, that is to say, when a chunk is free, its structure is used different to when in use. However, all chunks have a 4 byte (32 bit) header with the following structure :</p>
<ul>
<li>bits 01-24 : 24 bit - length (in bytes) of the chunk. <em>Yes, largest chunk (therefore largest heap) is 16meg.</em> </li>
<li>bits 25-28 : 4 bit - allocation 'type' of the memory, used by the garbage collector </li>
<li>bits 29-30 C : 2 bit - used by garbage collector to specific a GC 'colour' for the chunk </li>
<li>bit P 31 : 'prev-free' bit. <code>1</code> if previous chunk in the heap is free (used to coalesce), <code>0</code> if not </li>
<li>bit U 32 : 'in-use' bit. <code>1</code> if chunk is in-use, <code>0</code> if free.</li>
</ul>
<p>Like this:</p>
<pre class="fragment">  chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk (24 bits)                  | type  |  C|P|U|
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>After that header - for an in-use chunk - is the user-data, or for a free chunk is free-list housekeeping.</p>
<p>An in-use chunk has its U bit set to <code>1</code> and looks like this:</p>
<pre class="fragment">  chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk (24 bits)                  | type  |  C|P|1|
   data-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                                                               |
         +-                                                             -+
         :                whatever bytes have been requested             :
         :                                                               :
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>Free chunks have their U bit as <code>0</code> . Free chunks are placed into a free list by setting prev/next pointers within the bodies of the chunks to form the list. The last <code>sizeof(bvm_chunk_t*)</code> bytes of a free chunk are a pointer to the beginning of itself. This 'back-pointer' is used when freeing chunks to see if the previous located chunk in the heap is also free - if so, it can be coalesced.</p>
<p>As below:</p>
<pre class="fragment">  chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk (24 bits)                  | type  |  C|P|0|
   data-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Pointer to previous chunk in free list                        |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Pointer to next chunk in free list                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         :                                                               :
         :                  unused  bytes                                :
         :                                                               :
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Pointer to beginning of this chunk                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre><p>You can see now why the minimum chunk size is header + 3 pointers. :-) yes, 'unused bytes' may be of zero length.</p>
<p>When a chunk is freed its U bit is unset, and then if the chunk's P bit is set it removes the previous chunk from the free list and joins with it to form a larger chunk. Also, if a chunk's P bit is set it can look at the previous bytes (just before its own address) to get a pointer to the beginning of the previous chunk.</p>
<p>So a chunk whose previous chunk is free looks a bit like this:</p>
<pre class="fragment">         :                                                               :
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Pointer to beginning of previous chunk                        |
  chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | Size of this chunk (24 bits)                  | type  |  C|1|U|
   data-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         :                whatever bytes have been requested             :
         :                                                               :</pre><p>When freeing a chunk, if the next chunk is also free (no special bit is required, just use the size of the current being-freed chunk to calculate where the next one starts), remove it from the free list and join with it to create a new larger free chunk.</p>
<p>Finally, set the P bit of the next chunk (to mark that its previous chunk is free), insert the (now possibly coalesced and larger) free chunk into appropriate place in the free list, and set its last bytes to point to the beginning of itself.</p>
<p>When a chunk is to be allocated, the free list is scanned looking for the first free chunk that is equal to or larger than the requested size + overhead. It is removed from the free list. If the found free chunk is larger than required and the excess can be split off into another valid chunk then it is split and the remainder put back into the free list. This simple algorithm means we only take what is needed from a free chunk and give the rest back to the allocator.</p>
<p>Exhaustion:</p>
<p>If memory is requested and none can be granted for the requested size, a GC is performed and then the allocation re-attempted. A second failure will cause an out-of-memory situation (and an out of memory exception to be thrown).</p>
<p>Other Notes:</p>
<p>The free list uses known markers at its start and end. The start points backwards to <code>NULL</code> and the end points forwards to <code>NULL</code>. At the very beginning, start points forward to the end and vice versa. Free list traversal is thus bounded by these start and finish markers.</p>
<p>This is a fairly vanilla implementation and as-of-yet, no major optimisation has been but in. But, some thoughts might be:</p><ul>
<li>'free size buckets' to lessen the free chunks scanned</li>
<li>'good enough' size when allocating - like if the first free chuck found is (say) within 30% of the size requested then do not split the remaining bytes off to go back into the list, just use the whole lot chunk.</li>
<li>keep some kind of measure on fragmentation and only coalesce if things go beyond a certain limit.</li>
<li>only coalesce for chunks beyond a certain size, on the basis that VMs operate on many small allocations, just make those allocations / de-allocations easier. </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a651a07cdaf98eac5b157a98de7c2501c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651a07cdaf98eac5b157a98de7c2501c">&#9670;&nbsp;</a></span>bvm_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bvm_heap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the allocator to provide memory of the given size.</p>
<p>The size requested is massaged to be a correct multiple of <a class="el" href="heap_8h.html#a8def61921007fa502c3f92b25b283d07">BVM_CHUNK_ALIGN_SIZE</a>. Requesting 0 bytes will successfully return a void*. However, there is overhead and minimum allocation size is defined by <a class="el" href="heap_8h.html#a695780e2fb78b87aa004f97d5aee4a96">BVM_CHUNK_MIN_SIZE</a>. Continually requesting zero bytes will exhaust memory.</p>
<p>Unlike other allocators may do, this one will not return <code>NULL</code> if no memory can be allocated. If memory cannot be allocated a GC will be invoked and then allocation will be re-attempted. A second allocation failure will throw an <code>OutOfMemoryException</code> if the VM is initialised. If the VM has not yet been initialised the VM will exit with <a class="el" href="vm_8h.html#a942ca758c1e0462fbdee82b941dad338a4298b8e139dae661cd1b9f4e8e9ea0b4">BVM_FATAL_ERR_OUT_OF_MEMORY</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- the size in bytes to get </td></tr>
    <tr><td class="paramname">alloc_type</td><td>- the bvm_gc allocation type of the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* - a pointer to the allocated memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">OutOfMemoryException</td><td>if memory cannot be allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a097e1b325c892f999261c83fd7b1d9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097e1b325c892f999261c83fd7b1d9c0">&#9670;&nbsp;</a></span>bvm_heap_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bvm_heap_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide memory to the VM that is initialised to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- the size in bytes of the memory to allocate </td></tr>
    <tr><td class="paramname">alloc_type</td><td>- the bvm_gc allocation type of the memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ebde1065baed2244a7a0b553ce3ff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebde1065baed2244a7a0b553ce3ff7d">&#9670;&nbsp;</a></span>bvm_heap_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bvm_heap_clone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an exact copy of memory allocated by the allocator. New memory is allocated and the contents of the <code>ptr</code> argument are copied into it. The <code>ptr</code> argument must be a pointer to heap memory that was gained using <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> or <a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the memory to clone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cloned memory allocated from the heap. </dd></dl>

</div>
</div>
<a id="a487b6d04e5ec12b677b478fa9336a38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487b6d04e5ec12b677b478fa9336a38a">&#9670;&nbsp;</a></span>bvm_heap_debug_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_debug_dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug function to dump a table of the heap contents to the console. </p>

</div>
</div>
<a id="a439c0145a0d4ce11861133a66dcf3d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439c0145a0d4ce11861133a66dcf3d0f">&#9670;&nbsp;</a></span>bvm_heap_debug_dump_free_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_debug_dump_free_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug function to dump the free list to the console </p>

</div>
</div>
<a id="a01af772fb247fd5ab4e6bf8ebfcd5e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01af772fb247fd5ab4e6bf8ebfcd5e8d">&#9670;&nbsp;</a></span>bvm_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To release memory allocated by <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> or <a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a> back to the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to heap memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60b131ac3462e75acebe769bdcf44e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b131ac3462e75acebe769bdcf44e8b">&#9670;&nbsp;</a></span>bvm_heap_free_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a>* bvm_heap_free_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a chunk and place it back into the free list. In doing so, if the chunk's P bit is set the previous chunk is removed from the free list and coalesced with. Also, if the next chunk is free, it is also removed from the free list and coalesced.</p>
<p>This function is not intended for general developer use - just by the GC. Developers should use <a class="el" href="heap_8c.html#a01af772fb247fd5ab4e6bf8ebfcd5e8d">bvm_heap_free</a> on pointers returned from <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> or <a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a>.</p>
<p>No correctness checking is performed to ensure the chunk is a correct chunk or is not presently in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>- an in-use chunk to return to the free list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chunk that was free - this may be different to the requested chunk if the requested chunk was coalesced. </dd></dl>

</div>
</div>
<a id="acc9f20525b662e5f325a82c9d671bd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9f20525b662e5f325a82c9d671bd32">&#9670;&nbsp;</a></span>bvm_heap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the VM heap to <code>size</code> by requesting the memory from the OS using <a class="el" href="ansi_2c_2pd__memory_8c.html#a5ba1f1c73908f0d6add269169b11b6e5">bvm_pd_memory_alloc</a>. The size will be rounded to a multiple of the <a class="el" href="heap_8h.html#a8def61921007fa502c3f92b25b283d07">BVM_CHUNK_ALIGN_SIZE</a> setting and must be between <a class="el" href="heap_8h.html#ac1e2626b75e31ba6fe00b63bb17d3e70">BVM_HEAP_MIN_SIZE</a> and <a class="el" href="heap_8h.html#aadcb3d456762b1ebcd2fabdc7d148929">BVM_HEAP_MAX_SIZE</a>.</p>
<p>The free list is established with the list markers #free_list_start and #free_list_end as delimiters. The new heap space will become the first available chunk on the free list. Yes, the new heap memory is added as a free chunk to the free list. All subsequence allocations will subdivide this large free list chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- the heap size to allocate from the OS for the VM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a942ca758c1e0462fbdee82b941dad338aa94e07a8c47100058b20a632124a9d3e">BVM_FATAL_ERR_HEAP_SIZE_LT_THAN_ALLOWABLE_MIN</a></td><td>- if the requested heap size is less than the allowable VM lower limit set by <a class="el" href="heap_8h.html#ac1e2626b75e31ba6fe00b63bb17d3e70">BVM_HEAP_MIN_SIZE</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a942ca758c1e0462fbdee82b941dad338a6aaee88d0cf8a1b26ecea56e2fe0eb77">BVM_FATAL_ERR_HEAP_SIZE_GT_THAN_ALLOWABLE_MAX</a></td><td>- if the requested heap size is greater than the allowable VM upper limit set by <a class="el" href="heap_8h.html#aadcb3d456762b1ebcd2fabdc7d148929">BVM_HEAP_MAX_SIZE</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a942ca758c1e0462fbdee82b941dad338ab028c6bd9fc3676d2f958fb26159a50a">BVM_FATAL_ERR_CANNOT_ALLOCATE_HEAP</a></td><td>- if the requested heap size cannot be allocated from the OS. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe49028dcdf54023add0e2fedcc546a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe49028dcdf54023add0e2fedcc546a7">&#9670;&nbsp;</a></span>bvm_heap_is_chunk_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvm_heap_is_chunk_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For GC, To determine if a pointer to a chunk really points to a chunk. A number of tests are performed on the chunk - like checking its size and making sure it is within the heap address range and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>- the chunk to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bvm_bool_t - <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83cae1cc7e51faf7a61d39e7e31a03811117">BVM_TRUE</a> is the chunk is a true chunk, or <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a> otherwise </dd></dl>

</div>
</div>
<a id="a31127351be375d2cf70054e3fc160737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31127351be375d2cf70054e3fc160737">&#9670;&nbsp;</a></span>bvm_heap_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass the entire VM heap back to the operating system.</p>
<p>Called upon exit from the VM. </p>

</div>
</div>
<a id="a3ba620266351957528daaf88ac26d3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba620266351957528daaf88ac26d3b2">&#9670;&nbsp;</a></span>bvm_heap_set_alloc_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_heap_set_alloc_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the alloc type of a given pointer. The pointer must have been a heap pointer returned from <a class="el" href="heap_8c.html#a651a07cdaf98eac5b157a98de7c2501c">bvm_heap_alloc</a> or <a class="el" href="heap_8c.html#a097e1b325c892f999261c83fd7b1d9c0">bvm_heap_calloc</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to change the alloc type of. </td></tr>
    <tr><td class="paramname">alloc_type</td><td>the new alloc type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae569b93dc7870e12999ff2f34cf2b992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae569b93dc7870e12999ff2f34cf2b992">&#9670;&nbsp;</a></span>printFreeChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printFreeChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="heap_8h.html#a26b4041af7b43665e3ae24f79e1731a2">bvm_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afe901f5fd558757c72828199f98e242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe901f5fd558757c72828199f98e242e">&#9670;&nbsp;</a></span>bvm_gl_heap_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t* bvm_gl_heap_end</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer to one byte past the last byte of the heap </p>

</div>
</div>
<a id="a932e76c0c10c17f1cced691109716c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932e76c0c10c17f1cced691109716c84">&#9670;&nbsp;</a></span>bvm_gl_heap_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_heap_free</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The total memory (in bytes) in the free list </p>

</div>
</div>
<a id="a45c4b6068de2f551dfe1bb23be6703d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c4b6068de2f551dfe1bb23be6703d2">&#9670;&nbsp;</a></span>bvm_gl_heap_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_heap_size = <a class="el" href="define_8h.html#ace404562cc20b9250e9e430e6844371a">BVM_HEAP_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The total heap size in bytes. Defaults to <a class="el" href="define_8h.html#ace404562cc20b9250e9e430e6844371a">BVM_HEAP_SIZE</a>. </p>

</div>
</div>
<a id="a4fe5b937b911a670d0cadb34874327f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe5b937b911a670d0cadb34874327f5">&#9670;&nbsp;</a></span>bvm_gl_heap_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t* bvm_gl_heap_start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer to the first byte of the heap </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3b19ecf29356981f494745fbef7e56bf.html">c</a></li><li class="navelem"><a class="el" href="heap_8c.html">heap.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
