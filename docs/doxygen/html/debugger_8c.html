<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: src/c/debugger/debugger.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('debugger_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">debugger.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bvm_8h_source.html">../../h/bvm.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8aa42919b7bb519cf4385e81fda8f1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#ac8aa42919b7bb519cf4385e81fda8f1d">bvmd_nextid</a> ()</td></tr>
<tr class="separator:ac8aa42919b7bb519cf4385e81fda8f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665ed1c5beab40f23469da47d52d6b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a665ed1c5beab40f23469da47d52d6b0b">bvmd_is_vm_suspended</a> ()</td></tr>
<tr class="separator:a665ed1c5beab40f23469da47d52d6b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a388ec7fdd3a60a53fa938fcf3f5a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a6a388ec7fdd3a60a53fa938fcf3f5a19">bvmd_spin_on_debugger</a> ()</td></tr>
<tr class="separator:a6a388ec7fdd3a60a53fa938fcf3f5a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f1ef34f894c5166aaeeecab59f0447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a31f1ef34f894c5166aaeeecab59f0447">bvmd_init</a> ()</td></tr>
<tr class="separator:a31f1ef34f894c5166aaeeecab59f0447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868446931df8f85cb492759395b47c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a868446931df8f85cb492759395b47c00">bvmd_shutdown</a> ()</td></tr>
<tr class="separator:a868446931df8f85cb492759395b47c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8e148afd1a101c3ac90681e1e54a4c"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a9f8e148afd1a101c3ac90681e1e54a4c">bvmd_clazz_reftype</a> (<a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *clazz)</td></tr>
<tr class="separator:a9f8e148afd1a101c3ac90681e1e54a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83e8742da20790ce63e41606610c41d"><td class="memItemLeft" align="right" valign="top">bvm_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#ae83e8742da20790ce63e41606610c41d">bvmd_clazz_status</a> (<a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *clazz)</td></tr>
<tr class="separator:ae83e8742da20790ce63e41606610c41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416c559e92fc015ffa4c7e0aa9a04aff"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a416c559e92fc015ffa4c7e0aa9a04aff">bvmd_get_jdwptag_from_char</a> (char ch)</td></tr>
<tr class="separator:a416c559e92fc015ffa4c7e0aa9a04aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7ce793e26fc864920f2886902443bd"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#ada7ce793e26fc864920f2886902443bd">bvmd_get_jdwptag_from_jvmstype</a> (<a class="el" href="clazz_8h.html#a08a17e710757b662e4dc45b0075bf50d">bvm_jtype_t</a> type)</td></tr>
<tr class="separator:ada7ce793e26fc864920f2886902443bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf582eda2c9f5e3a3ec5854d5e9ff482"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#aaf582eda2c9f5e3a3ec5854d5e9ff482">bvmd_get_jdwptag_from_clazz</a> (<a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *clazz)</td></tr>
<tr class="separator:aaf582eda2c9f5e3a3ec5854d5e9ff482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0280e63d9c245f5f44cb497162235be6"><td class="memItemLeft" align="right" valign="top">bvm_uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a0280e63d9c245f5f44cb497162235be6">bvmd_get_jdwptag_from_object</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj)</td></tr>
<tr class="separator:a0280e63d9c245f5f44cb497162235be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aef4388045f5e4b611f421dd55f0f2e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#aef4388045f5e4b611f421dd55f0f2e11">bvmd_gl_enabledebug</a> = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td></tr>
<tr class="separator:aef4388045f5e4b611f421dd55f0f2e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e0bc3c199fd8daae9a1b5b623c913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#aec7e0bc3c199fd8daae9a1b5b623c913">bvmd_gl_server</a> = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td></tr>
<tr class="separator:aec7e0bc3c199fd8daae9a1b5b623c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f003f674d8cd091d7e28e52d79e11b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a8f003f674d8cd091d7e28e52d79e11b9">bvmd_gl_suspendonstart</a> = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td></tr>
<tr class="separator:a8f003f674d8cd091d7e28e52d79e11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d4218b09cff3a4fb200ab5d66c9935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a44d4218b09cff3a4fb200ab5d66c9935">bvmd_gl_all_suspended</a> = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td></tr>
<tr class="separator:a44d4218b09cff3a4fb200ab5d66c9935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce2d23fb8d58585e410cbc6f8ae720d"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a8ce2d23fb8d58585e410cbc6f8ae720d">bvmd_gl_timeout</a> = <a class="el" href="define_8h.html#a9a308af99d308359b0b1974881b5785e">BVM_DEBUGGER_TIMEOUT</a></td></tr>
<tr class="separator:a8ce2d23fb8d58585e410cbc6f8ae720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34400009d66ba7cf14229eefc240ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#acf34400009d66ba7cf14229eefc240ce">bvmd_gl_holdevents</a> = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td></tr>
<tr class="separator:acf34400009d66ba7cf14229eefc240ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9199f9c63c1a30185c5867a6e0acec"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#a2e9199f9c63c1a30185c5867a6e0acec">bvmd_gl_address</a> = NULL</td></tr>
<tr class="separator:a2e9199f9c63c1a30185c5867a6e0acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136dc180a79d21306be1549f70b6a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="object_8h.html#a075efb264fe732732d5aadf46cc1bde1">bvm_string_obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="debugger_8c.html#ac136dc180a79d21306be1549f70b6a5c">bvmd_nosupp_tostring_obj</a> = NULL</td></tr>
<tr class="separator:ac136dc180a79d21306be1549f70b6a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>JDWP functions.</p>
<h1><a class="anchor" id="debug-ov"></a>
Debugging Overview</h1>
<p>The Babe VM Java debugging facilities are an implementation of the Java Debug Wire Protocol (JDWP), which is a layer of the Java Platform Debug Architecture (JPDA). The JPDA is a useful standard that debuggers such as Intellij, VSCode, and Eclipse can implement (or build upon a reference implementation). As of Java 1.6, Sun deprecated other means of providing debugging facilities in a VM.</p>
<p>Not 100% of the JDWP specification is implemented in the Babe VM. Notable omissions are:</p>
<ul>
<li>The debugger cannot call methods in the VM. </li>
<li>The debugger cannot instantiate VM objects. </li>
<li>Classpath information is also not provided by the VM. </li>
<li>Nested type information for classes is not provided by the VM. </li>
<li>Classes can not be redefined on-the-fly, nor can methods be replaced. </li>
<li>Stack depth information for owned thread monitors is not provided. </li>
<li>Methods cannot be forced to return early. </li>
<li>'Referring objects' are not supported. </li>
<li>Instance counts are not provided. </li>
<li>Field access and modification breakpoints are not supported. </li>
<li>'Instance only' filtering for events is not supported.</li>
</ul>
<p>Still, without these (mostly optional) things it is possible to fully and effectively debug an application. Some optional extras are implemented such supporting JSR045 "Debugging Other Languages".</p>
<p>As a side note, many debuggers provide the ability to evaluate expressions on the fly (often called "conditional breakpoints"). This facility often involves calling methods in the VM - sometimes 'reflective' methods that are not implemented in Babe. As a result, conditional breakpoint use in most debuggers will be restricted.</p>
<p>Before explaining how the Babe VM implements JDWP it would be wise to provide a brief overview of the JDWP.</p>
<h1><a class="anchor" id="debug-jdwp-101"></a>
JDWP 101</h1>
<p>The JDWP defines an on-the-wire message exchange protocol between a Debugger (aka 'front end') and a Debuggee (aka 'back end' or 'VM'). The JDWP does not define the transport layer for how those messages move between parties. It defines what the messages are, and when they should be sent. The JDWP also defines the expected behaviour of a debuggee when it has received certain messages, and it expects the debuggee to attain certain states at certain times - for example, to suspend a thread when it has been told to do so.</p>
<h2><a class="anchor" id="debug-jdwp-messages"></a>
JDWP Messages</h2>
<p>The debugger/debuggee relationship is maintained by sending and receiving messages. The messages themselves are not complex. They are always either a 'command' or a 'reply'. Command and reply message headers are the same size but their payload data (if any) and format is defined on a per-message-type basis.</p>
<p>Typically, the messages that a debugger sends to the debuggee are 'commands'. Debugger-&gt;debuggee commands are either a request for information (like the value of a method-local variable), or a request to be notified by the debuggee that a particular event has occurred (like when a given class is loaded, or a given bytecode location is about to be executed).</p>
<p>The only time the debuggee sends the debugger a command is to signal that an event (which the debugger has requested to be notified about) has actually happened.</p>
<p>So the message flow between the two parties is really:</p>
<ul>
<li>Debugger-&gt;debuggee : commands for debuggee state information and also event registration. </li>
<li>Debuggee-&gt;debugger : replies to commands, and also registered-event command notifications.</li>
</ul>
<p>(Notice the debugger does not send replies to the debuggee? The JDWP spec says the debugger does not have to respond to commands from the debuggee - most debuggers don't).</p>
<p>So, it can largely be said that all messages relate to getting and setting state.</p>
<p>All these messages are async. Commands are sent. Commands are received. Replies are sent. Replies are received. The JDWP actually specifies that these things are asynchronous.</p>
<h2><a class="anchor" id="debug-jdwp-messages"></a>
JDWP Messages</h2>
<p>JDWP commands are divided logically into numbered groups of related commands called a 'commandset's. For example, one commandset will deal with messages/replies for thread references, and another commandset deals with stack frame information, another with methods and so on.</p>
<p>Within each commandset is a set of numbered commands. Each command message carries two bytes that specify the commandset and command.</p>
<p>Each command may carry data in its payload to further define the command - like a 'get thread name' command will specify the id of the thread to get the name of. Some commands carry no further information - like 'suspend all threads' needs nothing more.</p>
<p>Like commands, each reply may or may not have associated data. Unlike commands, replies have an error code - and it occupies the same bytes as the commandset/command.</p>
<h2><a class="anchor" id="debug-jdwp-ids"></a>
JDWP Identifiers (IDs)</h2>
<p>When a debugger requests (say) information on all threads, rather than serialise the threads in some way between debuggee/debugger, the debuggee will send the 'ID' of each thread. The ID is an opaque JDWP reference to something. The debugger has no knowledge of what the ID actually is within the debuggee, or how the debuggee actually manages those IDs. But, the IDs are used as the means to identify a given 'thing' between the two parties.</p>
<p>An ID is unique within the debug session. IDs are not reused and generally therefore cannot be tied simply to a memory address - although this is not always the case.</p>
<p>It is the responsibility of the debuggee to track all the IDs it has provided to the debugger. This does not mean that by handing the debugger an ID the debuggee can no longer garbage collect the associated 'thing', it just means that it has to know that it has/has not been collected when the debugger makes reference to the ID in a command.</p>
<p>Having said that, the debugger may actually ask the debuggee to <em>not</em> make an object eligible for garbage collection - even though it may be unreachable by the collector.</p>
<h2><a class="anchor" id="debug-jdwp-events"></a>
JDWP Events</h2>
<p>'Events' are the means by which a debugger can be notified when something occurs in the debuggee. Events are sent by the debuggee when the debugger has specifically requested it (the only exception to this are the VM start/death events, which are unsolicited).</p>
<p>The event notification lifecycle begins with the debugger sending an 'event set' command to the debuggee. Each 'event set' has an 'event kind' which defines the type of event the debugger is interested in (like say, an EXCEPTION eventkind - which notifies when an exception has occurred). Additionally, each 'event set' command may carry with it a number of 'filters' that further define the notification expectations of the debugger. For example, the above EXCEPTION eventkind request may have a filter on it to limit notification to a particular exception class type and it subtypes.</p>
<p>When the debuggee receives an 'event set' command its responsibility is to establish that definition, with filters, and then comply by sending the debugger event commands when an event occurs that satisfies and event definition and its filters.</p>
<p>An event definition and its associated filters remain active until such time as the debugger sends a command to the debuggee to 'clear' it.</p>
<p>Perhaps the most well known type of event is a 'breakpoint'. When the debugger user (developer) sets a breakpoint the debugger sends an 'event set' command to the debugger specifying the location of the breakpoint. Note that if the class has not yet been loaded by the debuggee, the debugger may actually first request to be notified of the 'CLASS_PREPARE' event, specifying a filter on the breakpointed class name - after it receives notification that the class has been loaded, it can clear the CLASS_PREPARE event, and now send a breakpoint 'event set' to the debuggee. Such is the way the two communicate.</p>
<p>After receiving a breakpoint command, the debuggee must then monitor program execution and when a bytecode execution location is reached that satisfies the filters on the breakpoint event definition, the debuggee must sent a breakpoint event command to the debugger.</p>
<h2><a class="anchor" id="debug-jdwp-suspendpolicy"></a>
JDWP Event Thread Suspension Policies</h2>
<p>Associated with each 'event set' that a debugger may send a debuggee is a 'thread suspend policy'. The policy describes what threads should have their execution suspended as the event is sent from the debuggee. The available policies are SUSPEND_NONE, SUSPEND_THREAD, and SUSPEND_ALL.</p>
<p>When an event command is sent from the debugger it must respect the suspend policy.</p>
<p>Why? Consider the above 'breakpoint' example, where the debugger has requested a breakpoint on a line in a class that has not yet been loaded by the debuggee - so the debugger actually first sends a CLASS_PREPARE 'event set' command specifying a class name filter. The debugger wants first to be notified that the class is loaded before it sets the breakpoint.</p>
<p>When the debuggee actually does load the class it will send a CLASS_PREPARE event command to the debugger. The debugger wants to set a breakpoint in the class before any code in it is executed, so .... it specifies a SUSPEND_THREAD policy for the CLASS_PREPARE event - which means that when the debuggee sends the CLASS_PREPARE event, it suspends the running thread immediately after it has sent the event. The debugger then (while the thread is suspended) sends a BREAKPOINT 'event set' back to the debuggee specifying a filter on the class and a location - and also with SUSPEND_THREAD policy on the breakpoint.</p>
<p>After setting the new breakpoint and clearing the class prepare event request (so the debuggee will not send that event again), it sends a command to resume the thread. Presto! The debugger suspended thread execution when it received notification of a class being loaded, set a breakpoint for the class, and then resumed thread execution.</p>
<p>A thread suspension policy of SUSPEND_ALL means that all threads in the debuggee will be suspended until such time as the debugger resumes one or all of them. In this state, debuggees generally will simply do nothing except wait for commands from the debugger.</p>
<p>Thread suspensions are counted - meaning a thread must be resumed the same number of times it has been suspended before it will truly resume execution.</p>
<h2><a class="anchor" id="debug-jdwp-jvmti"></a>
A note about JVMTI</h2>
<p>The Java Virtual Machine Tool Interface (JVMTI) is a standard interface layer on JNI for accessing state information about a VM and controlling it (like for debugging and/or profiling purposes).</p>
<p>The standard JDWP implementation is implemented as a JVMTI 'agent' - it rests on the functionality provided by JVMTI.</p>
<p>The JDWP specification is intended to be able to be implemented without JVMTI (indeed, JDWP existed before JVMTI) and is intended to be able to be implemented 'directly' just as the Babe VM does.</p>
<p>In implementing JDWP straight 'to-the-wire', rather than on top of JVTMI we can make life a lot simpler for this simple VM.</p>
<p>To that end, the Babe VM JDWP implementation does not use a JVMTI or JNI analogue.</p>
<h2><a class="anchor" id="debug-jdwp-transport"></a>
JDWP Transport Interface</h2>
<p>The JDWP specification is intended to be be 'transport agnostic' in the sense that the messages and behaviour are what it really defines - not how the messages get between parties.</p>
<p>However, for the purposes of standardisation among JVMTI VMs, there is a JDWP Transport Interface specification. This small specification defines a C interface struct used to nominate function pointers to functions for attaching to, listening for, closing, sending, receiving and so on.</p>
<p>The Babe VM uses a very similar approach and follows the JDWP transport specification (mostly). It uses the same pattern, but not necessarily in exactly the same way. For example, the spec defines 'send_packet' and 'read_packet' functions in the interface which operate at a high level on JDWP 'packets'. In this VM the interface uses 'send_bytes' and 'read_bytes' to operate at a lower level.</p>
<p>The JVMTI also defines lifecycle for the JDWP transport (and the JDWP agent for that matter), but we have no JVMTI analogue here so the lifecycle aspects of the transport are not there.</p>
<h1><a class="anchor" id="debug-babe-impl"></a>
The Babe VM JDWP Implementation</h1>
<p>This section provides an overview of how the JDWP specification is achieved in the Babe VM. This section will take the form of "how" sub-sections. Each subsection will provide an overview of how an particular aspect of JDWP spec is implemented.</p>
<h2><a class="anchor" id="debug-babe-impl-startup"></a>
VM startup with debugging</h2>
<p>The debugger facilities use a number of global variables with the prefix <code>'bvmd_gl_'</code>. Many of these variables are set as a result of parsing the commands line arguments <code>Xdebug</code> and <code>Xrunjdwp</code>. For example, the <a class="el" href="debugger_8c.html#aef4388045f5e4b611f421dd55f0f2e11">bvmd_gl_enabledebug</a> global will be <code>BVM_TRUE</code> if the command line has <code>Xdebug</code>.</p>
<p>At VM startup if the global variable <a class="el" href="debugger_8c.html#aef4388045f5e4b611f421dd55f0f2e11">bvmd_gl_enabledebug</a> is <code>BVM_TRUE</code>, debugging will be enabled for the life of the executing VM, otherwise, all debug facilities are bypassed and the VM operates largely as normal.</p>
<p>If debugging <em>is</em> enabled, the VM will attempt to establish communications with the debugger immediately after the VM has been initialised - even before the 'main' java class has been loaded.</p>
<p>How the VM establishes debugger communications depends on the transport implementation (described in the next section) and on some more global variable settings.</p>
<p>Firstly, the transport interface is initialised by calling <a class="el" href="debugger-io-transport_8h.html#a959060483239485d73ae4b8720027547">bvmd_transport_init</a>. This function may be replaced on a per-platform basis.</p>
<p>If <a class="el" href="debugger_8c.html#aec7e0bc3c199fd8daae9a1b5b623c913">bvmd_gl_server</a> is <code>BVM_TRUE</code> on VM startup the VM will ask the transport to listen on the address defined by <a class="el" href="debugger_8c.html#a2e9199f9c63c1a30185c5867a6e0acec">bvmd_gl_address</a>. The contents of <code>bvmd_gl_address</code> are of use only to the underlying transport. The VM places no inherent restriction on the format on the listening address. As an example, when listening the provided sockets transport treats the address as the port to listen on.</p>
<p>If <a class="el" href="debugger_8c.html#aec7e0bc3c199fd8daae9a1b5b623c913">bvmd_gl_server</a> is <code>BVM_FALSE</code> on VM startup the VM will ask the transport to 'attach' to the address defined by <a class="el" href="debugger_8c.html#a2e9199f9c63c1a30185c5867a6e0acec">bvmd_gl_address</a>. Again, the address is only meaningful to the transport. In the socket transport, the address is of the format "host:port" (but that is just for the provided socket transport).</p>
<p>The values of <a class="el" href="debugger_8c.html#a8ce2d23fb8d58585e410cbc6f8ae720d">bvmd_gl_timeout</a> will be passed to the transport as the timeout value.</p>
<p>Failure to establish communications with the debugger means the VM will continue as though <a class="el" href="debugger_8c.html#aef4388045f5e4b611f421dd55f0f2e11">bvmd_gl_enabledebug</a> where false.</p>
<p>If <a class="el" href="debugger_8c.html#a8f003f674d8cd091d7e28e52d79e11b9">bvmd_gl_suspendonstart</a> is <code>BVM_TRUE</code>, after establishing communications with the debugger the VM will suspend all threads and await commands from the debugger. It will remain in this suspended state until the debugger resumes it. The VM will then proceed normally and load the main class and start the interp loop as per normal.</p>
<p>From then on, with debugging communication established, some time is given to checking for commands from the debugger every thread switch.</p>
<h2><a class="anchor" id="debug-babe-impl-comms"></a>
Communicating with the Debugger</h2>
<p>As per the JDWP spec, messages pass between Babe and a debugger. The Babe debuggee code relies on a global C interface <a class="el" href="debugger-io-transport_8h.html#a7f1e298ca712caece1969e72931d9858">bvmd_gl_transport</a> (of type <a class="el" href="debugger-io-transport_8h.html#a0b3f5a4eebd5f5955038301f78b1cb66">bvmd_transport_t</a>) being populated with function pointers to transport functions for sending and receiving those messages.</p>
<p>This interface also defines the capabilities of the underlying transport, like whether it can listen or attach and so on. It allows the VM to request debug transport functionality without knowing the actual underlying transport or implementation.</p>
<p>In JDWP, messages are actually called 'packets', and in Babe they are represented by the <a class="el" href="debugger-io_8h.html#a80a45161f27bd53d874099f7c1b7b230">bvmd_packet_t</a> type which is a union of <a class="el" href="structbvmd__cmdpacket__t.html">bvmd_cmdpacket_t</a> and <a class="el" href="structbvmd__replypacket__t.html">bvmd_replypacket_t</a>. The JDWP spec is careful to make the size of a command the same size as a reply so they can generally be acted upon by the same code.</p>
<p>Debug packets may contain a linked list of 'packet data', represented by <a class="el" href="debugger-io_8h.html#aad98add38d8a496c0eff31effff6a6fe">bvmd_packetdata_t</a>. This linked list is the actual data payload of the packet. Every packetdata is a fixed size and may hold, at max, <a class="el" href="define_8h.html#ab6447cdee9c8c9baf96deb3f53da32f6">BVM_DEBUGGER_PACKETDATA_SIZE</a> bytes.</p>
<p>Even though the command and reply packets are largely the same animal, Babe differentiates between them when appropriate. Having them as the same structure means sending and receiving can use the same code for both commands and replies.</p>
<p>At each thread switch, the VM determines if there is anything waiting to be send to, or received from the debugger. If a packet is waiting to be read from the debugger, it is read, and if it is a command it is acted upon immediately and the reply send straight away. If it is a reply from the debugger it is simply ignored. Babe does nothing with reply packets received from the debugger.</p>
<h2><a class="anchor" id="debug-babe-impl-streams"></a>
Packet Streams</h2>
<p>Read and writing to a packet uses a 'streams' metaphor. Command and reply packets are not passed around inside the VM per-se, they are passed around as attributes of 'packet streams'. Babe packet streams are represented by the <a class="el" href="debugger-io_8h.html#a81dcb46b41da757767d8823cc3dbed41">bvmd_packetstream_t</a>, <a class="el" href="debugger-io_8h.html#a5a711b55f4e1d62ad9f6b7f78f2e06ba">bvmd_instream_t</a>, and <a class="el" href="debugger-io_8h.html#a3e3afc3103c4be7c05891bfe064dc34a">bvmd_outstream_t</a> types. All are actually the same, but the different names help to identifying usage within the code.</p>
<p>Each stream encompasses a packet, and keep references to the current <a class="el" href="debugger-io_8h.html#aad98add38d8a496c0eff31effff6a6fe">bvmd_packetdata_t</a> being read from / written to and within that, the current read/write location.</p>
<p>In reality, input streams are only populated with data when they are read from the transport. They are never written to. Likewise, output streams are never read from, only written to while creating something to send to the debugger. Output streams grow by adding to the <code>bvmd_packetdata_t</code> linked list within them as they are written to. Input stream are not extended as such as they are only ever manipulated during packet reading - and there the code is more specific.</p>
<p>Using an input stream to read packet data sent from the debugger and an output stream to create the packet and data to send to the debugger makes life much smoother. The size of a output stream is unknown and may grow as need be.</p>
<p>When the packet is finally being sent to the debugger, the packetdata linked list is traversed and all its data sent.</p>
<p>Input and output streams both have functions to read / write to them respectively.</p>
<h3><a class="anchor" id="debug-babe-impl-streams-bookmarks"></a>
Bookmarks</h3>
<p>On occasion, when writing to an output stream, the position of a write needs to be 'bookmarked' so that later the written data can be overwritten with a new value. This is especially useful when a 'length' needs to prefix a list of things that follow - and the length is not known until after the list is output. To assist, each of the write operations on an output stream returns a <a class="el" href="debugger-io_8h.html#ab951890488b4048b862211eba72cbec0">bvmd_streampos_t</a> bookmark. This bookmark can be used later to 'rewrite' some data back at some previous place in the stream. Typically, for lists where a 'length' precedes the list, a zero is first written to the stream, and then later, after the entire list has been written, the zero length is overwritten with the real length.</p>
<h3><a class="anchor" id="debug-babe-impl-streams-order"></a>
Host order vs Network Order</h3>
<p>All numeric data written to an output stream is first converted from 'host order' to 'network order'. So, even though on (say) Intel systems the 'host order' for numerics is little-endian, when they are written to the output stream they are converted to 'network order' (big-endian). Likewise for reading from stream. As numerics are read from an input stream, the reverse happens - they are converted from 'network order' to 'host order'.</p>
<h2><a class="anchor" id="debug-babe-impl-commands"></a>
Command Handling</h2>
<p>Each JDWP commandset has a corresponding array of function pointers to 'command handler' functions (<a class="el" href="debugger-commands_8h.html#acc335a8994a7776fda470e7cfecb2d39">bvmd_cmdhandler_t</a> function pointer type). Each function pointer corresponds to a given command within the commandset.</p>
<p>All commandset arrays are gathered into a single array of commandset arrays (yes, an array of arrays) named #bvmd_gl_command_sets.</p>
<p>When a command packet is received from the debugger, the 2 commandset / command bytes within the header are inspected and used to firstly find the right commandset array of command handlers, and then within that array, to find the specific command handler. The command handler function is called passing the input stream and also an output stream, where the command handler writes its response.</p>
<p>If the specified commandset/command is not valid, or the VM does not implement it, a default command handler is called that simply returns an error.</p>
<p>This simple structure means that command handling for a given command can be understood by locating the command handler. Often the command handlers are self-contained and are handled by just a single function.</p>
<h2><a class="anchor" id="debug-babe-impl-ids"></a>
ID Management</h2>
<p>The VM sends IDs for numerous things to the debugger. The JDWP spec defines a number of IDs type. Each may have its own size. In Babe, all IDs are four bytes.</p>
<p>When an ID is sent to the debugger, for some types an association between the ID and the memory address is kept.</p>
<p>The 'dbg id' map is where this takes place. This is actually two hash maps cross-linked by ID and address.</p>
<p>When any java object or VM <a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> is to be sent from VM to debugger, its address is looked up in the ID map to see it is already has a corresponding ID (meaning it has already been 'sent' to the debugger). If no entry is found a new one is created with a new unique ID to link the address and the ID. The ID it sent to the debugger.</p>
<p>During garbage collection, the collector inspects the dbg ID map as it frees memory - to remove an associated ID/address from the map. In this way, after a GC, any freed addresses will no longer be in the dbg ID map.</p>
<p>If the debugger specifies a given ID in a command (like say, a thread ID) and a lookup into the dbg ID map finds nothing, then it must have been garbage collected, and an error is returned to the debugger.</p>
<p>Note that only objects and clazzes get entries in the dbg ID map. Field IDs, Method IDs, and Frame IDs are communicated to the debugger as their actual in-memory address. Field and method IDs are always qualified by the debugger by their referencetype (clazz) IDs, so when using a field or a method ID, the dbg ID map is always checked first to make sure their associated clazz is still in there. A missing clazz entry in the dbg ID map means the clazz was collected and the ID (memory address) of the field or method should not be used and the debugger is sent an error reply.</p>
<p>Frame IDs are not managed in any way. Frame IDs sent to the debugger are actually the 'locals' pointer of a given frame on the stack. Tracking unique IDs as frames are pushed and popped would be a substantial amount of work for the VM, so here, we trust the debugger to make careful use of frame ids.</p>
<p>These ID management patterns are intended to reduce the number of entries in the dbg ID map, and therefore memory and processor time for ID lookups and management.</p>
<h2><a class="anchor" id="debug-babe-impl-threads"></a>
Threads</h2>
<p>Unlike many VMs, Babe does not use native threads, it has a 'green' threads implementation that is above the OS's threads. Green threads are both a blessing and a nightmare. Blessing because they mean portability - nightmare because they are not real threads and a thread 'suspend' does not really suspend a true 'thread'.</p>
<p>When the debugger sets an event request for (say) a CLASS_PREPARE, it associates a thread suspend policy with the event request so that when the VM does send an event for it, the suspend policy will be obeyed. Typically, for such an event, the policy will be SUSPEND_THREAD, meaning that just thread that the class prepare occurred in should be suspended.</p>
<p>In a VM with native threads, the entire running thread with C stack and Java stack would be suspended. Communications with the debugger occurs in a another thread. In the Babe VM, the C code cannot be suspended, it must keep going regardless of whether the current Java thread was suspended or not. Yes, the Java thread may be suspended, but C is not.</p>
<p>For this reason, sometimes in the VM debugger code you will see some gymnastics with regard to thread statuses. Effectively, when a thread is suspended by debugger interaction, it must, in the eyes of the debugger, do nothing else until resumed. That means it must cause no further events, or execute any bytecode until such time as it is resumed by the debugger.</p>
<p>Sometimes this is not possible. For example, say the debugger requests an event for a class prepare. Preparing a class also means preparing its parent and so on (if they are not already prepared). If one of the parent class prepare events causes an event and that causes the java thread to be suspended, the debugger does not want to see any more prepares or events AT ALL until it resumes the thread. But, we can't just stop the C code half way though a bunch of class prepares - it must keep going and return eventually to the interp loop. This is why you'll see 'parked events' on a thread. If a thread is suspended but the C code is still running and has stuff to do before it can return to the interp loop (where it can do a thread switch) any generated events are 'parked' on the thread waiting to be sent to the debugger when the thread is resumed.</p>
<p>This also happens with some bytecodes. For example, if an exception is thrown, the debugger may want an event and may cause the thread to be suspended. Which means halfway though processing the 'athrow' opcode, the thread gets suspended. To get around this, the exception details are held on the thread until such time as the thread can resume and deal with it <em>again</em> and finish processing it.</p>
<p>These sorts of things would not exist in a native threads VM. But, having said that, the mechanisms use to solve these issues are reasonably straight forward and documented well within the code.</p>
<p>Each time a thread is suspended or resumed all threads are examined to determine if all threads are now suspended. If all threads are suspended, then so is the VM. When the VM is suspended, it 'spins' on communications with the debugger until such time as a thread (or all of them) are again resumed and the interp loop can continue.</p>
<p>Have a look at the <a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> struct. You will see a number of members that are prefix with <code>'dbg_'</code>. These are members that are there specifically to assist with debugging.</p>
<h2><a class="anchor" id="debug-babe-impl-breakpoints"></a>
Breakpoints</h2>
<p>The way the Babe VM implements breakpoints and single stepping is worth some discussion. When a debugger requests a breakpoint it sends an event request for a BREAKPOINT and a number of filters that identify the class, method, and the breakpoint position within the method. The position may either be a line number (if the event step size is LINE), or a bytecode offset (if the event step size is BVM_MIN).</p>
<p>With a breakpoint, the JVMS already provides us with an opcode (202) that it anticipates VMs will use for breakpoint purposes. Babe does. What happens is this: the actual bytecode described by the BREAKPOINT event request is substituted with the (202) JVMS 'breakpoint' opcode. The original opcode is held with the BREAKPOINT event request.</p>
<p>As the code is executing (at normal pace), we want to know when the breakpoint has been reached. It is simple now, we just need to put code into the interp loop at the 202/breakpoint opcode. Bingo, we know it has been reached and can act.</p>
<p>Typically, the BREAKPOINT event will have a suspend policy of SUSPEND_THREAD, or SUSPEND_ALL. At any rate, it is likely the debugger has requested the running thread to suspend when the breakpoint is hit. (note, not always though - if a breakpoint has a 'count' on it, the breakpoint will be hit and only when the count is satisfied will the event be sent and the thread suspended).</p>
<p>Have a look at the <code><a class="el" href="exec_8c.html">exec.c</a></code> handling of <code>OPCODE_breakpoint</code>. It sends the breakpoint event, then flags the thread as being 'at breakpoint' and stores the original opcode with the thread. This original opcode will be the next opcode the threads executes. Look at the top of the interp loop. When debugging, the opcode is not determined simply by looking at the PC pointer - it is determined each time, and in this instance, it will be set to the original opcode displaced by the breakpoint opcode. So the original opcode gets the opportunity to run <em>after</em> the breakpoint opcode.</p>
<p>As breakpoint events are set and cleared, the opcode at the breakpoint location is displaced and re-placed. You'll notice that if the breakpoint logic encounters unexpected things it will cause a BVM_VM_EXIT. Breakpoints MUST be correct as opcodes are displaced and replaced and thus affect the actual correctness of the compiled code. It is safer to consider a breakpoint anomaly a VM-level disaster than try to figure out why code is running funny ....</p>
<p>Although a bit complicated to explain, breakpoints are rather simple in practice. More complicated is how single stepping is achieved ...</p>
<h2><a class="anchor" id="debug-babe-impl-singlestep"></a>
Single-Stepping</h2>
<p>Single stepping is what happens after a breakpoint is reached and the debugger instructs the VM to move - but only by a particular degree. This manifests itself as a SINGLE-STEP event request. The debugger is expecting the VM to sent a SINGLE-STEP event when it has 'stepped' by the requested degree. The 'degree' is define by two metric - the 'size' and the 'depth'.</p>
<p>Some background:</p>
<p>JDWP defines two step 'sizes'. MIN and LINE. The MIN size means 'move on by a single bytecode'. The LINE size means 'move on by one source line'.</p>
<p>Additionally, JDWP defines three different step 'depths'. INTO, OVER, and OUT. Interestingly, and very cleverly I think, in practice the three depths are not mutually exclusive. Initially they seem to be, but consider - what does an INTO do if you are on a line that does not actually call any methods? In that instance it must act like an OVER. But wait. What if you are actually on the last line of a method or a method's 'return' and therefore will not step INTO, or OVER any more lines within that method at all? In this case it must act like an OUT. See? The absence of one type of step means another must be checked and so on. An INTO step on the last line of a method that does not call any other methods is satisfied by the same conditions as an OUT.</p>
<p>This can be summarised as follows: an INTO can also be satisfied by an OVER or OUT. An OVER can also be satisfied by an OUT. An OUT can only be satisfied by an OUT. Clever.</p>
<p>Determining whether the program has 'stepped' or not is about measuring 'displacement'. "Has the PC for the current thread
moved to a position that satisfies the step event requirements?". Displacement is about measuring against INTO, OVER, OUT as above.</p>
<p>To measure displacement we must reference a starting point - so when the debugger sends an event request command for a SINGLE-STEP, the current execution position (class/method/'position'/stack-depth) is stored for the thread on the thread itself in the 'dbg_step' struct. We use these details to determine 'displacement'. 'Displacement' is the measure of how the execution point has moved since the SINGLE-STEP event request was received.</p>
<p>(Note: The stored 'position' depends on whether the step size in MIN or LINE. If it is MIN, we store the offset of the current executing bytecode within the executing method's bytecodes. If it is LINE, we store the current executing line number.)</p>
<p>While single-stepping, displacement is measured every executed bytecode at the top of the interp loop.</p>
<p>There are only three displacements that actually can be measured against the execution location when the SINGLE-STEP event request was received. Simply put, these are:</p>
<ul>
<li>Has the stack depth increased relative to when the single step was requested? If so, we have an INTO. </li>
<li>Has the stack depth decreased relative to when the single step was requested? If so, we have an OUT. </li>
<li>has the stack depth remained the same (same method is still executing), and the 'position' within the method moved. We have an OVER.</li>
</ul>
<p>If none of those, then no step has occurred.</p>
<p>Now recall, an INTO step-size can also be satisfied by an OVER, or OUT displacement. An OVER step-size can also be satisfied by an OUT displacement, and an OUT step-size can only be satisfied by an OUT displacement.</p>
<p>If we measure the displacement between the current execution location and the location at the time the single step event was requested using the above logic, we know whether we need to send a SINGLE-STEP event back to the debugger.</p>
<p>That is, if the debugger has requested an INTO step size, we test for INTO, OVER, and OUT displacements. If the debugger has requested an OVER step size, we test for OVER and OUT displacements. And lastly, the if the debugger has requested an OUT, we test only for an OUT displacement.</p>
<p>One last note: If the next opcode to execute after a step has been reached is actually an <code>OPCODE_breakpoint</code> opcode, the stepping logic detects this and checks for breakpoint events to send as well. The <a class="el" href="debugger-events_8h.html#a66f60be620414e934e34ee5b3580d66b">bvmd_event_SingleStep</a> method can do single steps events as well as breakpoint events that occur at the same location.</p>
<h2><a class="anchor" id="debug-babe-impl-exception"></a>
Exception Breakpoints</h2>
<p>Debuggers can request the VM for event notification when an exception occurs. Typically, using a debugger, a developer somehow informs the debugger to break when an exception for a particular class is thrown. The exception can be filtered further by specifying whether to break on caught/uncaught occurrences, or both.</p>
<p>A debugger then sends an EXCEPTION event request and often specifies a number of filters to narrow down the type of the exception. In a way, this is just another breakpoint. Debuggers use a thread suspend policy to ensure the thread (or all of them) is suspended as the actual event is sent from the VM to the debugger.</p>
<p>The debugger needs to be informed of an exception <em>before</em> the executing thread's stack is altered in any way to cater for the exception. During normal VM execution, when an exception is encountered, the stack is unwound down to where exception hander code is (if caught), or (if uncaught) to the very bottom of the stack. This usually just a single set of operations that happen as part of the VM's processing of an exception.</p>
<p>However, debugging complicates this by wanting to be informed of the exception <em>before</em> the stack unwind is done - and then to also have sent as part of the event the location where the exception is caught (or not caught ...). This means that the VM has to break up exception handing into two parts. The first part locates the position of the caught exception (if any), and the second part unwinds the stack. If an exception event is to be sent, it is sent as a sandwich between these two arts.</p>
<h2><a class="anchor" id="debug-babe-impl-unloading"></a>
Class Unloading</h2>
<p>During GC, Babe will unload unused classes if their classloader is unreachable. If a debugger has requested to be notified of class unloads events, cool - this is supported. However, it is worth a discussion to explain how it is done and why it is done in that manner.</p>
<p>Firstly, sending events to the debugger allocates heap memory, but class unloading happens during GC, so the events cannot be send during a GC cycle - we do not allocate memory during a GC. So, classes to be unloaded must be stored somewhere and unload events sent after the GC has finished.</p>
<p>When debugging, if the GC attempts to unload a class it will park it at the end of the <a class="el" href="debugger-events_8h.html#ad7a6d67ccb8c43240fede0a45b44990f">bvmd_gl_unloaded_clazzes</a> list. The GC cleans up everything except the clazz's basic <code>bvm_clazz_t</code> struct. The clazz is removed from the clazz pool and is placed onto this 'to be unloaded' list. The list is checked each thread switch.</p>
<p>The implementation gets over some subtle error conditions. Consider, when traversing the parked clazzes and sending events, sending the event allocates heap memory and therefore may cause a GC - we have to be very careful with how the list is used. After an event send the parked clazz list may actually have more unloaded clazzes on the end that were placed there by a GC.</p>
<p>More insidiously, a GC will actually find the <em>same</em> clazzes still in the heap and therefore want to add them <em>again</em> to the list (the clazz is, after all, not reachable but still in the heap). To solve this, as a clazz is parked its heap allocation type is changed to <a class="el" href="collector_8h.html#a18a8e77daa8a6efa343cf1ad8c49b696">BVM_ALLOC_TYPE_STATIC</a> to ensure any subsequent GC cycles ignore it.</p>
<p>After sending the unload event for a parked classes, the clazz memory is returned to the heap via <a class="el" href="heap_8h.html#a01af772fb247fd5ab4e6bf8ebfcd5e8d">bvm_heap_free</a>.</p>
<h2><a class="anchor" id="debug-babe-impl-perf"></a>
Debugging performance and memory usage</h2>
<p>A final note about debugging and the performance of the VM when the debugging capability is compiled in.</p>
<p>The VM will run slower when debugging code is compiled in. It will only run marginally slower when not actually debugging - that is, if the VM is not connected to a debugger stuff should run only a bit slower. When connected to a debugger it would be reasonable to expect a greater drop in performance.</p>
<p>While connected to a debugger, more things happen each thread switch and more things happen while loading classes and so on. A large part of the additional work is checking if any packets from the debugger are waiting to be read and processed.</p>
<p>Single-stepping while debugging takes a fair bit of processing to accomplish. Each bytecode execution requires a) examining the stack depth, and b) examining the current execution position (normally this means figuring the executing source code line number). Perhaps not mountains of it, but when you compare the effort the VM goes through to check for that 'next step' with the simple bytecode switch when not debugging, there is a pretty big difference.</p>
<p>Compiling in debugger support also means extra heap is used to load stuff like clazz method line numbers and local variable tables. During a debugging session, extra heap is also used to keep track of events and their modifiers, as well as ID/address mapping and so on. (Having said this, all debugging and development was done using the 128k default heap).</p>
<p>So why say all of this? Just to say that unless you're happy with the performance of the VM with debugging support compiled in, and can spare the extra memory required to have the extra class info loaded - you really shouldn't, unless you have specific reasons to do so, ship the VM with debugging support compiled in. Nuff said.</p>
<p>... except also also that the debug code may actually double the executable program size - depending on platform.</p>
<dl class="section author"><dt>Author</dt><dd>Greg McCreath </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.0.10 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9f8e148afd1a101c3ac90681e1e54a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8e148afd1a101c3ac90681e1e54a4c">&#9670;&nbsp;</a></span>bvmd_clazz_reftype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t bvmd_clazz_reftype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the JDWP ReferenceType for a given clazz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>a give clazz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the JDWP refernce type of the given clazz. </dd></dl>

</div>
</div>
<a id="ae83e8742da20790ce63e41606610c41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83e8742da20790ce63e41606610c41d">&#9670;&nbsp;</a></span>bvmd_clazz_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_int32_t bvmd_clazz_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the JDWP status of a given clazz. JDWP Note: Clazz states are cumulative - the status reflected here is <em>all</em> the statuses that the clazz has passed through so far. Weird, but true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>a given clazz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the JDWP status of the given clazz </dd></dl>

</div>
</div>
<a id="a416c559e92fc015ffa4c7e0aa9a04aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416c559e92fc015ffa4c7e0aa9a04aff">&#9670;&nbsp;</a></span>bvmd_get_jdwptag_from_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t bvmd_get_jdwptag_from_char </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the JDWP tagtype from the first character of a given JNI signature. Note that this will only determine whether the signature specifies a primitive or an array. If the signature describes an object type, this function will return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>the first character of a given JNI signature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the JDWP tagtype if the signature represents a primitive or an array. Zero will be returned for JNI signatures for object types. </dd></dl>

</div>
</div>
<a id="aaf582eda2c9f5e3a3ec5854d5e9ff482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf582eda2c9f5e3a3ec5854d5e9ff482">&#9670;&nbsp;</a></span>bvmd_get_jdwptag_from_clazz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t bvmd_get_jdwptag_from_clazz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#aad944a281f999674be45ed9044896991">bvm_clazz_t</a> *&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the JDWP tag of a given clazz. JDWP note: If the clazz is for an array or primitive type then the tag reflects this. If the clazz is for an object type, then JDWP has that further broken down to the type of object it is - like String, Thread, Class, or ClassLoader. If the object is none of these the return tag is simply for an object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>a given clazz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the JDWP tag for the given clazz. </dd></dl>

</div>
</div>
<a id="ada7ce793e26fc864920f2886902443bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7ce793e26fc864920f2886902443bd">&#9670;&nbsp;</a></span>bvmd_get_jdwptag_from_jvmstype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t bvmd_get_jdwptag_from_jvmstype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a08a17e710757b662e4dc45b0075bf50d">bvm_jtype_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the JDWP tag of a given JVMS type. The JVMS type is a enumeration up to 11, whereas the JDWP tag is a single char representation of a type. This function provides a mapping between the two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>a given JVMS type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0280e63d9c245f5f44cb497162235be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0280e63d9c245f5f44cb497162235be6">&#9670;&nbsp;</a></span>bvmd_get_jdwptag_from_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint8_t bvmd_get_jdwptag_from_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the JDWP tag for a given object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>a given object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the JDWP tag for the object, or <a class="el" href="debugger-jdwp_8h.html#af5e67c5f6069cf257c30a713cbd48e06">JDWP_Tag_OBJECT</a> if the object is <code>NULL</code>. </dd></dl>

</div>
</div>
<a id="a31f1ef34f894c5166aaeeecab59f0447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f1ef34f894c5166aaeeecab59f0447">&#9670;&nbsp;</a></span>bvmd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs one-time startup initialisation of the VMs debugging facilities. </p>

</div>
</div>
<a id="a665ed1c5beab40f23469da47d52d6b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665ed1c5beab40f23469da47d52d6b0b">&#9670;&nbsp;</a></span>bvmd_is_vm_suspended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_is_vm_suspended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports whether the VM is current suspended. </p>

</div>
</div>
<a id="ac8aa42919b7bb519cf4385e81fda8f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aa42919b7bb519cf4385e81fda8f1d">&#9670;&nbsp;</a></span>bvmd_nextid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bvmd_nextid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides an ID to identify objects and packets. Counting starts at 1.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID. </dd></dl>

</div>
</div>
<a id="a868446931df8f85cb492759395b47c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868446931df8f85cb492759395b47c00">&#9670;&nbsp;</a></span>bvmd_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform one-time shutdown and finalisation of the VM debug facilities. </p>

</div>
</div>
<a id="a6a388ec7fdd3a60a53fa938fcf3f5a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a388ec7fdd3a60a53fa938fcf3f5a19">&#9670;&nbsp;</a></span>bvmd_spin_on_debugger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_spin_on_debugger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the VM to spin waiting on a command from the debugger that will unsuspend the VM. Has no effect if the VM is current not suspended. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2e9199f9c63c1a30185c5867a6e0acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9199f9c63c1a30185c5867a6e0acec">&#9670;&nbsp;</a></span>bvmd_gl_address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bvmd_gl_address = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The address a debugger transport (<a class="el" href="debugger-io-transport_8h.html#a0b3f5a4eebd5f5955038301f78b1cb66">bvmd_transport_t</a>) will use to connect or listen. Can be set using command line <code>-Xrunjdwp</code> as the 'address'. The address may mean different things depending on whether the VM is attaching to the debugger, or listening for a connection. </p>

</div>
</div>
<a id="a44d4218b09cff3a4fb200ab5d66c9935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d4218b09cff3a4fb200ab5d66c9935">&#9670;&nbsp;</a></span>bvmd_gl_all_suspended</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_gl_all_suspended = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag telling whether all threads are currently in a suspended state. Not for use by developers. As a thread is suspended or terminated or resumed this flag is reset. </p>

</div>
</div>
<a id="aef4388045f5e4b611f421dd55f0f2e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4388045f5e4b611f421dd55f0f2e11">&#9670;&nbsp;</a></span>bvmd_gl_enabledebug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_gl_enabledebug = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable debug at startup. This variable is only inspected as the VM start to see if debug should be enabled, and during shutdown to see if cleanup should be done. Can be set with command line option -Xdebug. </p>

</div>
</div>
<a id="acf34400009d66ba7cf14229eefc240ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf34400009d66ba7cf14229eefc240ce">&#9670;&nbsp;</a></span>bvmd_gl_holdevents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_gl_holdevents = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating whether the debugger has requested suspension of all events from the VM to the debugger. The VM considers this as a 'suspension' and cause the entire VM to suspend waiting for the debugger to resume event sending again. </p>

</div>
</div>
<a id="aec7e0bc3c199fd8daae9a1b5b623c913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7e0bc3c199fd8daae9a1b5b623c913">&#9670;&nbsp;</a></span>bvmd_gl_server</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_gl_server = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies whether the VM is in debug server mode (which means it listens for a connection from a debugger). Set using the server=y/n setting on the <code>Xrunjdwp</code> command line option. </p>

</div>
</div>
<a id="a8f003f674d8cd091d7e28e52d79e11b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f003f674d8cd091d7e28e52d79e11b9">&#9670;&nbsp;</a></span>bvmd_gl_suspendonstart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_gl_suspendonstart = <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to determine if the VM suspends all thread on startup pending connection with a debugger. Can be set on command line as the suspend=y/n setting of the <code>Xrunjdwp</code> option. Only valid if <code>server=y</code> setting on the <code>Xrunjdwp</code> option. </p>

</div>
</div>
<a id="a8ce2d23fb8d58585e410cbc6f8ae720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce2d23fb8d58585e410cbc6f8ae720d">&#9670;&nbsp;</a></span>bvmd_gl_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvmd_gl_timeout = <a class="el" href="define_8h.html#a9a308af99d308359b0b1974881b5785e">BVM_DEBUGGER_TIMEOUT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default timeout for connections to/from debugger. Can be set with command line -dbg_timeout. Defaults to compile-time variable <a class="el" href="define_8h.html#a9a308af99d308359b0b1974881b5785e">BVM_DEBUGGER_TIMEOUT</a>. </p>

</div>
</div>
<a id="ac136dc180a79d21306be1549f70b6a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac136dc180a79d21306be1549f70b6a5c">&#9670;&nbsp;</a></span>bvmd_nosupp_tostring_obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="object_8h.html#a075efb264fe732732d5aadf46cc1bde1">bvm_string_obj_t</a>* bvmd_nosupp_tostring_obj = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3b19ecf29356981f494745fbef7e56bf.html">c</a></li><li class="navelem"><a class="el" href="dir_6d3094a74f5125361c1cbd78410c720e.html">debugger</a></li><li class="navelem"><a class="el" href="debugger_8c.html">debugger.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
