<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: src/c/thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thread_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bvm_8h_source.html">../h/bvm.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed37a60e3a76ff5493b1a476f581af01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#aed37a60e3a76ff5493b1a476f581af01">bvm_thread_create_stack</a> (bvm_uint32_t height)</td></tr>
<tr class="separator:aed37a60e3a76ff5493b1a476f581af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cebeef654ecbf422d5d78c123667fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a56cebeef654ecbf422d5d78c123667fc">bvm_thread_create_vmthread</a> (<a class="el" href="thread_8h.html#a4878a893e32e512f0e411358910eb935">bvm_thread_obj_t</a> *thread_obj)</td></tr>
<tr class="separator:a56cebeef654ecbf422d5d78c123667fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0901e383e5d89ee5c93ce54925169f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ac0901e383e5d89ee5c93ce54925169f9">bvm_do_thread_interrupt</a> ()</td></tr>
<tr class="separator:ac0901e383e5d89ee5c93ce54925169f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f6cb03f0b95b2d2c4efeb17435c976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ae0f6cb03f0b95b2d2c4efeb17435c976">bvm_thread_switch</a> ()</td></tr>
<tr class="separator:ae0f6cb03f0b95b2d2c4efeb17435c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a9a8c1a03cee49c4c8e3835643c3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ac1a9a8c1a03cee49c4c8e3835643c3f8">bvm_thread_terminated_callback</a> (<a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *res1, <a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *res2, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> is_exception, void *data)</td></tr>
<tr class="separator:ac1a9a8c1a03cee49c4c8e3835643c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48bfb8e077c30261a6575135baffa59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ac48bfb8e077c30261a6575135baffa59">bvm_thread_start</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> push_run_method)</td></tr>
<tr class="separator:ac48bfb8e077c30261a6575135baffa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af628995fd6497323f66d1e27917dab22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#af628995fd6497323f66d1e27917dab22">get_monitor_for_obj</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj)</td></tr>
<tr class="separator:af628995fd6497323f66d1e27917dab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d4f9d6ef3e02dbe792994fcefaf69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a2b9d4f9d6ef3e02dbe792994fcefaf69">bvm_thread_calc_timeslice</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a2b9d4f9d6ef3e02dbe792994fcefaf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ad2b24f2d5326d8c708bad44fccb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a8b3ad2b24f2d5326d8c708bad44fccb2">bvm_thread_sleep</a> (<a class="el" href="structbvm__int64__t.html">bvm_int64_t</a> sleep_time)</td></tr>
<tr class="separator:a8b3ad2b24f2d5326d8c708bad44fccb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccda5d41ef23475a89a256612250b32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#acccda5d41ef23475a89a256612250b32">bvm_thread_wait</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj, <a class="el" href="structbvm__int64__t.html">bvm_int64_t</a> wait_time)</td></tr>
<tr class="separator:acccda5d41ef23475a89a256612250b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af30841153ca1caf4f5fc3c9c29e77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a8af30841153ca1caf4f5fc3c9c29e77a">bvm_thread_monitor_acquire</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj, <a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a8af30841153ca1caf4f5fc3c9c29e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49942720edd9c8bf6a929bbfb58a3266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a49942720edd9c8bf6a929bbfb58a3266">bvm_thread_monitor_release</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj)</td></tr>
<tr class="separator:a49942720edd9c8bf6a929bbfb58a3266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c7d40b005c5da735b3e108cd5ffe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a9b9c7d40b005c5da735b3e108cd5ffe3">bvm_thread_notify</a> (<a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *monitor, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> do_all)</td></tr>
<tr class="separator:a9b9c7d40b005c5da735b3e108cd5ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa28e69f8b64d7362f1c20ca1323958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#afaa28e69f8b64d7362f1c20ca1323958">bvm_thread_interrupt</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:afaa28e69f8b64d7362f1c20ca1323958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db6ca91196e32a957a25818f688cef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a8db6ca91196e32a957a25818f688cef7">bvm_thread_push_exceptionhandler</a> (<a class="el" href="object_8h.html#a2b4f8c559a1a0a4eeae0bdcec0077e89">bvm_throwable_obj_t</a> *throwable)</td></tr>
<tr class="separator:a8db6ca91196e32a957a25818f688cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae146db66ffdd8c19c10e4987185b8218"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ae146db66ffdd8c19c10e4987185b8218">bvm_thread_get_next_id</a> ()</td></tr>
<tr class="separator:ae146db66ffdd8c19c10e4987185b8218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672b77e9f610add125c63b3740d8b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ac672b77e9f610add125c63b3740d8b38">bvm_init_threading</a> ()</td></tr>
<tr class="separator:ac672b77e9f610add125c63b3740d8b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b34cce7ba5d62af00bd135f4bb5ff76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a6b34cce7ba5d62af00bd135f4bb5ff76">bvm_thread_is_alive</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a6b34cce7ba5d62af00bd135f4bb5ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62023494ef3e2590c4499a4c09270451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a62023494ef3e2590c4499a4c09270451">bvm_thread_load_registers</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a62023494ef3e2590c4499a4c09270451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce112e2ebc629e24312be75b8fadfbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a3ce112e2ebc629e24312be75b8fadfbd">bvm_thread_store_registers</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a3ce112e2ebc629e24312be75b8fadfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100c13ce5e10a7f949d71101182ae034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a100c13ce5e10a7f949d71101182ae034">bvm_stack_get_depth</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a100c13ce5e10a7f949d71101182ae034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2686763eab4bb62861061a3518a6e159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a2686763eab4bb62861061a3518a6e159">bvm_stack_visit</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread, int startframe, int count, int *depth, <a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a> callback, void *data)</td></tr>
<tr class="separator:a2686763eab4bb62861061a3518a6e159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b8e159d7eec1470a82b1b13fb09bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a801b8e159d7eec1470a82b1b13fb09bb">bvmd_check_thread_suspensions</a> ()</td></tr>
<tr class="separator:a801b8e159d7eec1470a82b1b13fb09bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b8ee1b6c42593df91a41d43d1fde08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ab0b8ee1b6c42593df91a41d43d1fde08">bvmd_thread_suspend</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:ab0b8ee1b6c42593df91a41d43d1fde08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45fdb729ce913744b988a33413b705e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#af45fdb729ce913744b988a33413b705e">bvmd_thread_suspend_all</a> ()</td></tr>
<tr class="separator:af45fdb729ce913744b988a33413b705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d0330b2a97002599aa4685f87d823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a955d0330b2a97002599aa4685f87d823">bvmd_thread_resume</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a955d0330b2a97002599aa4685f87d823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df44a35e1c9eccc585b58ba11891c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a2df44a35e1c9eccc585b58ba11891c63">bvmd_thread_resume_all</a> (<a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> force, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> clear_parked)</td></tr>
<tr class="separator:a2df44a35e1c9eccc585b58ba11891c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3103edb0d6121eadc5515931f5d888d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ae3103edb0d6121eadc5515931f5d888d">bvm_gl_threads</a> = NULL</td></tr>
<tr class="separator:ae3103edb0d6121eadc5515931f5d888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb533cfd34cc4e480e87ce71814df92c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#adb533cfd34cc4e480e87ce71814df92c">bvm_gl_thread_current</a> = NULL</td></tr>
<tr class="separator:adb533cfd34cc4e480e87ce71814df92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa9ec2c16c741d31c81f1b486f6b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ad7aa9ec2c16c741d31c81f1b486f6b46">bvm_gl_thread_runnable_list</a> = NULL</td></tr>
<tr class="separator:ad7aa9ec2c16c741d31c81f1b486f6b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f928ebdecfc4190387445b8642b9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a08f928ebdecfc4190387445b8642b9cd">bvm_gl_thread_monitor_list</a> = NULL</td></tr>
<tr class="separator:a08f928ebdecfc4190387445b8642b9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baf57251d155d33bf5c9e5aa0dfd415"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a5baf57251d155d33bf5c9e5aa0dfd415">bvm_gl_thread_active_count</a> = 0</td></tr>
<tr class="separator:a5baf57251d155d33bf5c9e5aa0dfd415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d96f81852fa23ce07b3e89a886f7f7"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a39d96f81852fa23ce07b3e89a886f7f7">bvm_gl_thread_nondaemon_count</a> = 0</td></tr>
<tr class="separator:a39d96f81852fa23ce07b3e89a886f7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae9d398762b8469ad48b570f46d5d55"><td class="memItemLeft" align="right" valign="top">bvm_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a9ae9d398762b8469ad48b570f46d5d55">bvm_gl_thread_timeslice_counter</a></td></tr>
<tr class="separator:a9ae9d398762b8469ad48b570f46d5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Everything to do with threads for the VM.</p>
<dl class="section author"><dt>Author</dt><dd>Greg McCreath </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.0.10</dd></dl>
<h1><a class="anchor" id="threads-overview"></a>
Overview</h1>
<p>The VM has a full threads implementation including all locking and waiting semantics as per the JVMS.</p>
<p>The threads implementation does not use native threads. It is a preemptive 'green' threads implementation that operates above the OS - here, VM threads are independent of the underlying operating system threads even if it supports them.</p>
<p>All threading is managed within the VM. In the 'keep it simple' philosophy, this removes the need to port a threading implementations to for each platform and makes it all a lot easier to understand.</p>
<p>Internally, the VM uses no native threads at all. That is not to say that on some platform ports that (say) printing may not use a native thread to do its thing asynchronously. The important thing is that to the java layer, it all looks the same. Keep it simple.</p>
<p>Not all of the Java threads API is implemented - however, most of it is there. At this point, thread groups are not supported - they seems to offer nothing for a small platform. Methods that specify nano-seconds are also not supported. I imagine for most of the platforms this VM is ported to we'll be lucky to get a resolution less than a second.</p>
<p>The notable omissions from standard Java threads are :</p>
<ul>
<li>ThreadGroups </li>
<li>Reflective stuff like getting a list of all threads. </li>
<li>All deprecated (and dangerous) stuff like stop/suspend/resume.</li>
</ul>
<p>... but apart from that it's all to the letter of the JVMS/JDK.</p>
<p>Each Java thread object has a handle to an internal VM thread (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>) and vice-versa. So when a Java Thread method is called that is native, the VM can translate the call from a Java thread object to a VM thread. All VM operations concerning threads deal with the internal <a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> objects.</p>
<p>In this code unit, the only references to java thread objects are 1) to create a VM thread for a given Java Thread object, 2) to start a Java Thread object (we need to get its class and find the 'run' method), and 3) to create the bootstrap VM thread and its associated Thread Java object.</p>
<p>In all instances, to find out how threads work in this VM at a Java level, you may refer to Java documentation for threading.</p>
<h1><a class="anchor" id="thread-lifecycle"></a>
Thread creation, startup, and termination</h1>
<p>VM threads are not created in isolation. Every VM thread needs a Java thread as its buddy. With the sole exception of the bootstrap thread, the VM never creates a VM thread to do something outside of Java. After all, a VM thread is really just a means for a Java thread to execute bytecode.</p>
<p>Of course, the reverse is not true, an executing Java program can create as many thread objects as it cares to. Actually, the VM does not care )or know) how many it <em>creates</em> - that is just Java bytecode. The VM only cares when Java cares to <em>start</em> one. Starting a Java thread is when the VM becomes involved with it.</p>
<p>Before any Java thread object can start executing bytecode it must have a VM thread associated with it. VM threads manage the execution of the Java thread bytecode.</p>
<p>All threads have a stack. At thread startup, all threads have their 'run' method pushed onto the thread's stack. This is the starting point for thread bytecode execution. The 'run' method is chosen carefully. If a thread has been instantiated with a target <code>java.lang.Runnable</code> object, the <code>run()</code> method of the <code>Runnable</code> object is pushed, otherwise the run method of the Thread (or subclass thereof) is pushed. Special care is required here as the 'run' method itself may be synchronised. If so, the VM must attempt to lock the about-to-run thread object's monitor (more later on this). If it cannot, the thread is blocked and added to the thread object's monitor lock queue (more later ...) and will be dealt with like all other threads waiting on a monitor lock queue.</p>
<p>The VM must know when a thread has finished executing. And when it does it has to take action to clean it up and change status etc. To do this, at thread startup the VM places a 'callback wedge' stack frame as the first frame of the thread's execution stack. When the execution thread drops down to this special frame it calls the callback method to clean up the thread etc etc. Bingo, it gets terminated and is no longer considered for selection for execution.</p>
<p>A terminated thread has its stack memory freed straight away and does not wait for the next GC. No real reasonfopr that - just that we know it is memory that is no longer used.</p>
<p>For more information on how frames and thread startup works, see the frames documentation at <a class="el" href="frame_8c.html#frame-overview">Frames and Stacks</a>.</p>
<h1><a class="anchor" id="threads-bootstrap"></a>
Bootstrap</h1>
<p>This is nice and simple. At boot, the VM creates a single Thread object and (like every other thread) has the 'run' method pushed onto its execution stack. Remember, the 'run' method of the Java Thread class actually does nothing. But ... on top of that, the static 'main' method is then pushed. Additionally, the Thread class initialiser method <code>&lt;clinit&gt;</code> is then pushed.</p>
<p>VM execution thus begins with the Thread class initialisation, then 'main' method.</p>
<p>After the 'main' method has finished, the frame-pop reinstates the 'run' method - which does nothing so it is also popped. Finally after that is the thread callback wedge frame as described above.</p>
<p>See the frames documentation at <a class="el" href="frame_8c.html#frame-overview">Frames and Stacks</a>.</p>
<h1><a class="anchor" id="threads-monitors"></a>
Object Monitors</h1>
<p>A monitor (<a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a>) is used when an object becomes involved in synchronised activity. The monitor is the central control for things waiting on an object - be it for a sync lock, or for a wait.</p>
<p>Whenever an object is the target of a sync block or synchronised method it will have a monitor allocated for it from the heap.</p>
<p>The monitor contains important information. Firstly, it has a handle to the thread that currently owns the monitor. Only one thread at a time can own the monitor. Refer to the Java JDK docs for more info on that. The monitor also has a pointer to the object it is a monitor for.</p>
<p>Additionally, the monitor contains two queues for VM threads. One is a queue of threads that want to lock the monitor, (and therefore desire to have exclusive access to its associated object for threading purposes). This is called the "lock queue".</p>
<p>The other monitor queue is a queue for threads that are 'waiting' on it as a consequence of using the java Object.wait() method. This is called the "wait queue".</p>
<p>Threads waiting on an object never actually hold a lock on it, therefore a thread can only be be in one queue or the other - never both at the same time. That is to say, the lock queue and the wait queue are mutually exclusive.</p>
<p>The VM thread maintains a 'next_in_queue' member to point to the next thread in the same queue. If it is the end of a queue (or not in one at all) this member will be <code>NULL</code>.</p>
<p>When a thread 'wait' expires (if it indeed has a timeout), or the object has been the target of a Java <code>notify()</code> or <code>notifyAll()</code> the thread in question will attempt to lock the monitor and become its owner. If it cannot do this, it simply goes into the monitor's lock queue and will be dealt with like all other threads in the lock queue - awaiting a chance to become the exclusive owner.</p>
<p>The monitor also maintains the lock 'depth' as described in the JVMS. It is incremented each time the current owner thread locks it, and decremented when is unlocks it. A thread that issues a <code>wait()</code> on a monitor stores its current lock depth in the VM thread structure and is placed in the monitor's wait queue after relinquishing all lock(s) on it. At some later stage when it again becomes the owner of the monitor the lock depth is restored (as per the JVMS).</p>
<p>Monitors are cached. When it is time to acquire a monitor, a cache (which is a simple linked list with its head at <a class="el" href="thread_8c.html#a08f928ebdecfc4190387445b8642b9cd">bvm_gl_thread_monitor_list</a>) is first inspected - if the cache is empty or no 'unused' monitors exist, a new monitor is allocated from the heap. When that monitor is no longer used it will be emptied, marked as unused, and left in the list to be reused later.</p>
<h1><a class="anchor" id="threads-threelists"></a>
Three Thread Lists</h1>
<p>The VM maintains three lists of threads.</p>
<p>The first list is simply a list of all threads. As a thread is created is is added to this list. This 'global' list is used by the GC to and scan and mark threads, or if they are terminated, remove them from the list.</p>
<p>The other two lists are mutually exclusive and represent the 'runnable' threads and the 'timed callback' threads. The VM thread structure has a field called #next_in_list. This points to the next thread in the same list. It will be <code>NULL</code> if the thread in question is at the end of a list or not in one at all.</p>
<p>The 'runnable' list contains only those threads that the VM can execute. It does not have to make any decisions about threads in this list. It gives each one execution time and cycles around them.</p>
<p>Threads in the 'timed callback' list are waiting for a timeout so that they may execute a callback. At this point, callbacks are only used for timed wait() invocation and for sleep() invocations. When a thread goes into this list it has a 'time_to_wake' calculated for it. When this time expires it is removed from the list and placed back into the runnable list.</p>
<p>Likewise, a thread in the runnable list that becomes the subject of a sleep() or a timed wait() is removed from the runnable list and (with a calculated timeout) placed in the timed-callback list.</p>
<p>Each time a thread switch occurs, the timed-callback list if traversed to see if any thread's time-to-wake has passed. If so, the callback is executed.</p>
<p>Sometimes, the runnable list may be exhausted while the timed-callback list is not. In this case, the VM will keep spinning through the timed-callback list until a thread becomes runnable again.</p>
<p>All threads in the runnable list will have the status <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600ada00aa4e7a1bbb7414269e83f67240eb">bvm_vmthread_t::BVM_THREAD_STATUS_RUNNABLE</a>. All threads in the timed-callback list will have the static <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a>.</p>
<h1><a class="anchor" id="threads-status"></a>
Thread Status</h1>
<p>There are four distinct VM thread statuses along with two status modifiers for blocked threads.</p>
<ul>
<li><a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a322bf0d1c86150e818bb3e362ce0b360">bvm_vmthread_t::BVM_THREAD_STATUS_NEW</a> </li>
<li><a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600ada00aa4e7a1bbb7414269e83f67240eb">bvm_vmthread_t::BVM_THREAD_STATUS_RUNNABLE</a> </li>
<li><a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a> </li>
<li><a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600aaede24a699c6f460e946b4d32608182d">bvm_vmthread_t::BVM_THREAD_STATUS_TERMINATED</a></li>
</ul>
<p>All VM threads start life with a status of BVM_THREAD_STATUS_NEW. Very quickly, they are moved to either BVM_THREAD_STATUS_RUNNABLE, or to BVM_THREAD_STATUS_BLOCKED.</p>
<p>New threads become BVM_THREAD_STATUS_BLOCKED straight away if their 'run' method is synchronised and they cannot become the owner of their own monitor when they attempt to start. Generally, new threads become BVM_THREAD_STATUS_RUNNABLE when started and are placed into the runnable list.</p>
<p>Only BVM_THREAD_STATUS_BLOCKED threads may become BVM_THREAD_STATUS_RUNNABLE.</p>
<p>When a thread is terminated it gets the BVM_THREAD_STATUS_TERMINATED status. Nice and simple. Only BVM_THREAD_STATUS_RUNNABLE threads may be terminated.</p>
<p>The BVM_THREAD_STATUS_BLOCKED status needs a bit of explanation. Any 'active' thread (one that is not BVM_THREAD_STATUS_NEW or BVM_THREAD_STATUS_TERMINATED) that is not BVM_THREAD_STATUS_RUNNABLE must be in a BVM_THREAD_STATUS_BLOCKED state. A blocked thread will not appear in the runnable list, and <em>may</em> appear in the timed-callback list. Seems simple enough, but there actually, are three sorts of 'blocked'.</p>
<p>Firstly, there is (I guess) 'vanilla' blocked which is when a thread is blocked waiting on a sync method or block. No time-outs involved and therefore the thread is not in the timed-callback list. It will remain BVM_THREAD_STATUS_BLOCKED until it gets access to the monitor it seeks.</p>
<p>The other blocked states are for threads that are waiting or sleeping - they are in the timed-callback list. They still have a status of BVM_THREAD_STATUS_BLOCKED but are or'd with the BVM_THREAD_STATUS_WAITING or BVM_THREAD_STATUS_TIMED_WAITING modifiers depending on the type of (erm) wait they are undertaking.</p>
<p>According to the Java SDK Docs:</p>
<p>BVM_THREAD_STATUS_WAITING is "Thread state for a waiting thread. A thread is in the waiting state due to
calling one of the following methods"</p>
<ul>
<li>Object.wait with no timeout </li>
<li>Thread.join with no timeout</li>
</ul>
<p>BVM_THREAD_STATUS_TIMED_WAITING is "Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time:"</p>
<ul>
<li>Thread.sleep </li>
<li>Object.wait with timeout </li>
<li>Thread.join with timeout</li>
</ul>
<p>Additionally, an extra status is associated with remote debugging - #BVM_THREAD_STATUS_DBG_SUSPENDED. This is set when a remote debugger requests a thread be suspended.</p>
<h1><a class="anchor" id="threads-scheduling"></a>
Scheduling</h1>
<p>The VM thread scheduler is very simple. It works on a round-robin basis for those threads that are BVM_THREAD_STATUS_RUNNABLE. Each thread is given a 'timeslice' which is calculated as 'thread priority * thread_default_timeslice'. Each thread will execute this number of bytecodes before a thread 'context' switch is requested. The next available BVM_THREAD_STATUS_RUNNABLE thread is selected, the bytecode execution counter reset to the thread's calculated timeslice, and away it goes again.</p>
<p>The #thread_default_timeslice global var is defaulted to the <a class="el" href="define_8h.html#aae4f0b0a4269ad1e1aee57390dbea004">BVM_THREAD_TIMESLICE</a> compile time constant.</p>
<p>At each thread switch, if the timed-callback list has any entries it is scanned to see if any threads in that list can have their callbacks executed (which <em>may</em> place them back into the runnable list).</p>
<p><em>NOTE : I guess this could be more efficient. The VM could scan the list only when it knows their will be something to callback - each time a thread is added to the list a 'next visit time' could be calculated and the list would be ignored until then. Keeping the list in 'time_to_wake' order could assist this.</em></p>
<p>Occasionally, the VM forces a thread switch by setting the bytecode execution counter to zero. This means a thread switch will occur before the next bytecode is executed.</p>
<h1><a class="anchor" id="threads-stacks"></a>
Threads Stacks</h1>
<p>Each thread has it own stack. Instead of taking the high road with stack sizes and creating each thread with a stack large enough to accommodate its most severe possible requirements - this VM does exactly the opposite - it creates each thread with the <em>smallest</em> possible stack and grows and shrinks it dynamically.</p>
<p>The <a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a> type represents a stack used by a thread. Actually, the thread maintains a linked-list of them. There is always at least one stack in the list for a non-terminated thread. Instead of throwing a StackOverFlow error when the stack is exhausted, the VM creates a new stack and adds it to the end of the current stack. Of course, if the current stack <em>already</em> has a 'next' one then that stack will be used if the new frame will fit in it - otherwise it will be discarded (and become GC'd) and a new stack created that <em>will</em> accommodate the new frame.</p>
<p>The stack may grow and shrink as required. Shrinking is performed during GC by truncating the list at the current stack in the list. This is done by setting its 'next' pointer to <code>NULL</code>. That means between GCs a thread will create a stack list as tall as it needs to and later during GC, if it is not used any more it will be cut back down to only what is being used.</p>
<p>This approach gives the VM the ability to run many threads will little overhead. A thread, its java object, and its stack can literally be as small as a couple of hundred bytes (in 32 bit).</p>
<p>When a thread is terminated its stacks are immediately released back to the heap. They will never be used again so they are freed straight away.</p>
<p>Using dynamic stacks has implications for the what is stored per frame on the stack. To support this, an extra element is in each stack frame - that element is a reference to the stack that the frame lives in. This way, as a frame is popped, the stack it was in becomes the 'current' stack, just like the method in the popped frame becomes the 'current' method. There is a corresponding global register for the current stack called <a class="el" href="frame_8h.html#a1ef5174928a07c65d1c37d73ce547dcb">bvm_gl_rx_stack</a>.</p>
<h1><a class="anchor" id="threads-daemons"></a>
Daemon Threads</h1>
<p>The VM supports Daemon threads. The VM will shut down when all non-daemon threads are terminated. Any Daemon threads left running at that stage are simply never given any more time and will cease bytecode execution.</p>
<h1><a class="anchor" id="threads-uncaught"></a>
Uncaught Exceptions</h1>
<p>Java 1.5 introduced the idea that uncaught exceptions in threads could be acted upon rather than just letting the thread die quietly. This VM uses the Java SE defined means of catching and acting upon uncaught exception in threads, albeit with one difference - there are no threadgroups involved. When an exception is uncaught, the VM pushes the thread's 'dispatchUncaughtException' method onto the stack - and that is all. The rest is bytecode. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac0901e383e5d89ee5c93ce54925169f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0901e383e5d89ee5c93ce54925169f9">&#9670;&nbsp;</a></span>bvm_do_thread_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_do_thread_interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a pending thread interrupt for the current executing thread. If the thread had a pending exception, that exception is thrown, otherwise <a class="el" href="vm_8h.html#a2f728b9bd377378f1c624d6c30c96942">BVM_ERR_INTERRUPTED_EXCEPTION</a> is thrown.</p>
<p>Before the exception is thrown, the interrupted status of the thread is cleared. </p>

</div>
</div>
<a id="ac672b77e9f610add125c63b3740d8b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac672b77e9f610add125c63b3740d8b38">&#9670;&nbsp;</a></span>bvm_init_threading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_init_threading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs initialisation for threading at VM startup </p>

</div>
</div>
<a id="a100c13ce5e10a7f949d71101182ae034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100c13ce5e10a7f949d71101182ae034">&#9670;&nbsp;</a></span>bvm_stack_get_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bvm_stack_get_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the depth of a given thread's stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the depth. </dd></dl>

</div>
</div>
<a id="a2686763eab4bb62861061a3518a6e159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2686763eab4bb62861061a3518a6e159">&#9670;&nbsp;</a></span>bvm_stack_visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_stack_visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startframe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit a given thread's stack from the top to the bottom calling an optional callback handler for each frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the given thread </td></tr>
    <tr><td class="paramname">startframe</td><td>the frame number to start at - the callback will not be invoked until this depth is reached. Pass in zero to start at the very top. </td></tr>
    <tr><td class="paramname">count</td><td>the number of frame to visit after <code>startframe</code> frames have been visited. -1 means go all the way. </td></tr>
    <tr><td class="paramname">depth</td><td>an optional integer pointer that can be used by the calling function to count the total number of frames traversed. So, <code>'startframe=0'</code> and 'length=-1' this will return the depth of the stack. </td></tr>
    <tr><td class="paramname">callback</td><td>an optional <a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a> function pointer to call for each visited frame after <code>startframe</code> has been reached. The callback will be passed a bvm_stack_frame_info_t handle describing the frame. </td></tr>
    <tr><td class="paramname">data</td><td>an optional handle to data to pass to the callback when it is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b9d4f9d6ef3e02dbe792994fcefaf69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9d4f9d6ef3e02dbe792994fcefaf69">&#9670;&nbsp;</a></span>bvm_thread_calc_timeslice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_calc_timeslice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate and set the timeslice for a given thread. A thread's timeslice is its priority multiplied by the #thread_default_timeslice var - this gives the number of bytecodes to execute before a thread switch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread to set the timeslice of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed37a60e3a76ff5493b1a476f581af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed37a60e3a76ff5493b1a476f581af01">&#9670;&nbsp;</a></span>bvm_thread_create_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a>* bvm_thread_create_stack </td>
          <td>(</td>
          <td class="paramtype">bvm_uint32_t&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a stack for a thread. The new stack is allocated from the heap and will have its <code>top</code> calculated and its <code>next</code> pointer set to <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>- the height in cells of the new stack (note: NOT in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly created <a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a>. </dd></dl>

</div>
</div>
<a id="a56cebeef654ecbf422d5d78c123667fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cebeef654ecbf422d5d78c123667fc">&#9670;&nbsp;</a></span>bvm_thread_create_vmthread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_thread_create_vmthread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a4878a893e32e512f0e411358910eb935">bvm_thread_obj_t</a> *&#160;</td>
          <td class="paramname"><em>thread_obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a VM thread from a given Java thread object. Establishes the VM thread to wrap the Java thread. The VM thread is created with a new stack. The size of the stack is determined from the global <a class="el" href="vm_8h.html#aabd88661b1ef14f97c64b3132bf8f290">bvm_gl_stack_height</a> variable - this in turn is defaulted from <a class="el" href="define_8h.html#afe109b1f4ea024f841f12f5dc9a4be95">BVM_THREAD_STACK_HEIGHT</a>.</p>
<p>The new VM thread is created with a state of <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a322bf0d1c86150e818bb3e362ce0b360">bvm_vmthread_t::BVM_THREAD_STATUS_NEW</a> and added at the head of the global list of threads pointed to by <a class="el" href="thread_8c.html#ae3103edb0d6121eadc5515931f5d888d">bvm_gl_threads</a>.</p>
<p>Note that this does NOT start a thread. Threads do not start until explicitly started by <a class="el" href="thread_8c.html#ac48bfb8e077c30261a6575135baffa59">bvm_thread_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_obj</td><td>- the Java thread object to create a VM thread for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vm thread </dd></dl>

</div>
</div>
<a id="ae146db66ffdd8c19c10e4987185b8218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146db66ffdd8c19c10e4987185b8218">&#9670;&nbsp;</a></span>bvm_thread_get_next_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_thread_get_next_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the next id for a thread. Used for allocation if thread id's at the Java level. </p>

</div>
</div>
<a id="afaa28e69f8b64d7362f1c20ca1323958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa28e69f8b64d7362f1c20ca1323958">&#9670;&nbsp;</a></span>bvm_thread_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt a given thread. If the thread is waiting it is given a 'pending' exception to throw when it wakes and set to wake up immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b34cce7ba5d62af00bd135f4bb5ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b34cce7ba5d62af00bd135f4bb5ff76">&#9670;&nbsp;</a></span>bvm_thread_is_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvm_thread_is_alive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether a given thread is 'alive'. A thread is alive if it is not \ NULL, is not NEW, and is not TERMINATED. </p>

</div>
</div>
<a id="a62023494ef3e2590c4499a4c09270451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62023494ef3e2590c4499a4c09270451">&#9670;&nbsp;</a></span>bvm_thread_load_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_load_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the thread registers to the global registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread with registers to copy to global. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8af30841153ca1caf4f5fc3c9c29e77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af30841153ca1caf4f5fc3c9c29e77a">&#9670;&nbsp;</a></span>bvm_thread_monitor_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvm_thread_monitor_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Have the given thread attempt to acquire the given object's monitor. It the thread can acquire the object's monitor it becomes the owner of that monitor. If it cannot acquire it, the thread becomes blocked and is added to the lock queue of the monitor and will have to re-attempt it at some other time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to lock upon </td></tr>
    <tr><td class="paramname">vmthread</td><td>the thread that is attempt to get the object lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83cae1cc7e51faf7a61d39e7e31a03811117">BVM_TRUE</a> if the monitor was acquired, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a4c8aca107356ddf11fb56b41e47900e1">BVM_ERR_NULL_POINTER_EXCEPTION</a></td><td>if obj is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49942720edd9c8bf6a929bbfb58a3266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49942720edd9c8bf6a929bbfb58a3266">&#9670;&nbsp;</a></span>bvm_thread_monitor_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_monitor_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a lock on an object. If the lock depth on the object's monitor reaches zero, promote another waiting thread (if any) to be the new owner of the object's monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to release a lock on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a4c8aca107356ddf11fb56b41e47900e1">BVM_ERR_NULL_POINTER_EXCEPTION</a></td><td>if obj is null. </td></tr>
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a9a7dbf96f69a21759af02cffdaf08cdf">BVM_ERR_ILLEGAL_MONITOR_STATE_EXCEPTION</a></td><td>if the monitor's owner thread is not the current thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9c7d40b005c5da735b3e108cd5ffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c7d40b005c5da735b3e108cd5ffe3">&#9670;&nbsp;</a></span>bvm_thread_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>do_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notifies one or all threads waiting on an object's monitor. Performs the equivalent of the java <code>notify()</code> and <code>notifyAll()</code> logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object that threads may be waiting on </td></tr>
    <tr><td class="paramname">do_all</td><td>if <code>BVM_TRUE</code>, notify all waiting threads, if <code>BVM_FALSE</code>, notify just a single waiting thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a9d5c9887acc25ad404fc4c22799546b6">bvm_vmthread_t::BVM_THREAD_STATUS_WAITING</a> and <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a47d2a12dff7c62354ca5c7732a2c326f">bvm_vmthread_t::BVM_THREAD_STATUS_TIMED_WAITING</a> states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db6ca91196e32a957a25818f688cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db6ca91196e32a957a25818f688cef7">&#9670;&nbsp;</a></span>bvm_thread_push_exceptionhandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_push_exceptionhandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="object_8h.html#a2b4f8c559a1a0a4eeae0bdcec0077e89">bvm_throwable_obj_t</a> *&#160;</td>
          <td class="paramname"><em>throwable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push the java.lang.Thread::dispatchUncaughtException() method for the current thread onto the stack.</p>
<p>This method is called when an uncaught exception has been encountered for a thread - that is, exception handling went all the way to the bottom of the stack and did not find a handler.</p>
<p>This enables Java developers to pick up the mess.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">throwable</td><td>the uncaught exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b3ad2b24f2d5326d8c708bad44fccb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3ad2b24f2d5326d8c708bad44fccb2">&#9670;&nbsp;</a></span>bvm_thread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbvm__int64__t.html">bvm_int64_t</a>&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current thread to sleep a given number of milliseconds.</p>
<p>After this function, the thread will be <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a> with a <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a47d2a12dff7c62354ca5c7732a2c326f">bvm_vmthread_t::BVM_THREAD_STATUS_TIMED_WAITING</a> modifier and will be in the timed-callback list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleep_time</td><td>the time to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac48bfb8e077c30261a6575135baffa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48bfb8e077c30261a6575135baffa59">&#9670;&nbsp;</a></span>bvm_thread_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>push_run_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a new VM thread, set it up to run the correct thread <code>run()</code> method and attempt to get it started.</p>
<p>Two frames are pushed onto the stack. The first is a callback wedge that, when reached, signals that the thread has finished execution, and the second is (optionally) the java <code>run()</code> method to execute.</p>
<p>If the <code>run()</code> method is not synchronised, the thread status is set momentarily to <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a>, and then usual blocked-thread resumption code kicks in to unblock it and add it to the runnable list (all using #thread_resume).</p>
<p>If the run method is synchronised, an attempt is made to gain the monitor for the thread object. If it can be acquired, the same process for an synchronised \ run() method happens and the thread ends up being runnable and in the runnable list. If the monitor cannot be acquired, the thread enters a blocked state and waits on the monitor like any other blocked thread waiting on a monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>- the thread to start </td></tr>
    <tr><td class="paramname">push_run_method</td><td>- if BVM_FALSE, do thread startup but do not push the 'run' method as described above - just the callback wedge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a322bf0d1c86150e818bb3e362ce0b360">bvm_vmthread_t::BVM_THREAD_STATUS_NEW</a> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce112e2ebc629e24312be75b8fadfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce112e2ebc629e24312be75b8fadfbd">&#9670;&nbsp;</a></span>bvm_thread_store_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_store_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the global registers to the thread registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread to copy the global registers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f6cb03f0b95b2d2c4efeb17435c976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f6cb03f0b95b2d2c4efeb17435c976">&#9670;&nbsp;</a></span>bvm_thread_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_switch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch from the current thread to the next runnable thread.</p>
<p>The timeslice counter will be set to the timeslice for the selected thread. If the current thread is the only runnable thread it will remain current and, of course, the thread timeslice counter is reset.</p>
<p>Each time this function is called the timed callback list is scanned (if there is anything in it).</p>
<p>TODO: A more efficient means of checking the callback list is required. Maybe every 'n' times this function is called might be a simple way. A better way would be to only check it when sure there is something to resume - like doing a smart thing when adding something to the list. </p>

</div>
</div>
<a id="ac1a9a8c1a03cee49c4c8e3835643c3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a9a8c1a03cee49c4c8e3835643c3f8">&#9670;&nbsp;</a></span>bvm_thread_terminated_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a>* bvm_thread_terminated_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td>
          <td class="paramname"><em>res1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td>
          <td class="paramname"><em>res2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>is_exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The callback from the interp loop when a thread reaches the bottom of its execution stack. Will cause a thread switch to the next runnable thread. The exited thread has it status set to <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600aaede24a699c6f460e946b4d32608182d">bvm_vmthread_t::BVM_THREAD_STATUS_TERMINATED</a> and its stack memory freed. Any other thread waiting on this thread's monitor are notified.</p>
<p>Params unused in termination callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res1</td><td></td></tr>
    <tr><td class="paramname">res2</td><td></td></tr>
    <tr><td class="paramname">is_exception</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600ada00aa4e7a1bbb7414269e83f67240eb">bvm_vmthread_t::BVM_THREAD_STATUS_RUNNABLE</a> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acccda5d41ef23475a89a256612250b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccda5d41ef23475a89a256612250b32">&#9670;&nbsp;</a></span>bvm_thread_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbvm__int64__t.html">bvm_int64_t</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the current thread to wait on another object. If a wait time is specified, the thread will be added to the timed-callbacks list and will try to acquire the monitor of the given object when it wakes.</p>
<p>If no wait_time is given, the thread is added to the given object's monitor wait queue.</p>
<p>In all cases, the current thread will become blocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to wait on. </td></tr>
    <tr><td class="paramname">wait_time</td><td>the time in milliseconds to wait for it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a801b8e159d7eec1470a82b1b13fb09bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801b8e159d7eec1470a82b1b13fb09bb">&#9670;&nbsp;</a></span>bvmd_check_thread_suspensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvmd_check_thread_suspensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether all threads are suspended. Has the side effect of setting <a class="el" href="debugger_8h.html#a44d4218b09cff3a4fb200ab5d66c9935">bvmd_gl_all_suspended</a> to BVM_TRUE is all threads are suspended.</p>
<dl class="section return"><dt>Returns</dt><dd><code>BVM_TRUE</code> if all thread are suspended, <code>BVM_FALSE</code> otherwise. </dd></dl>

</div>
</div>
<a id="a955d0330b2a97002599aa4685f87d823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955d0330b2a97002599aa4685f87d823">&#9670;&nbsp;</a></span>bvmd_thread_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_thread_resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resume a thread in a 'debugger' way. Any thread acted upon by this function will have its thread suspend count reduced. If the count is reduced to zero the thread will be resumed for real <em>if</em> the only thing making it suspended is the debugger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>a given thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2df44a35e1c9eccc585b58ba11891c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df44a35e1c9eccc585b58ba11891c63">&#9670;&nbsp;</a></span>bvmd_thread_resume_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_thread_resume_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>clear_parked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes all threads in a 'debugger' way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>if <code>BVM_TRUE</code>, the thread will be resumed regardless of how many times the debugger has suspended it. </td></tr>
    <tr><td class="paramname">clear_parked</td><td>if <code>BVM_TRUE</code>, the thread will have any parked debug events cleared and releaseed to the heap (they are abandoned). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0b8ee1b6c42593df91a41d43d1fde08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b8ee1b6c42593df91a41d43d1fde08">&#9670;&nbsp;</a></span>bvmd_thread_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_thread_suspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend a thread in a 'debugger' way. This actually does a normal suspend on the thread if it is not already suspended and then (regardless of whether it was already suspended or was not) increments the thread debug suspension counter. The thread will gain a status of <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600aac51e2dee89f15b31b2ea2a8594e87e6">bvm_vmthread_t::BVM_THREAD_STATUS_DBG_SUSPENDED</a> if it was not already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>a given thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af45fdb729ce913744b988a33413b705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45fdb729ce913744b988a33413b705e">&#9670;&nbsp;</a></span>bvmd_thread_suspend_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvmd_thread_suspend_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspend all threads in a 'debugger' way. </p>

</div>
</div>
<a id="af628995fd6497323f66d1e27917dab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af628995fd6497323f66d1e27917dab22">&#9670;&nbsp;</a></span>get_monitor_for_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a>* get_monitor_for_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan the monitor list for a matching object. If none found, returns <code>NULL</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bvm_monitor_t for the given object, or <code>NULL</code> if not found. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5baf57251d155d33bf5c9e5aa0dfd415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baf57251d155d33bf5c9e5aa0dfd415">&#9670;&nbsp;</a></span>bvm_gl_thread_active_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_thread_active_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter of all the active (daemon and non-daemon) threads. Where active = started and not yet terminated </p>

</div>
</div>
<a id="adb533cfd34cc4e480e87ce71814df92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb533cfd34cc4e480e87ce71814df92c">&#9670;&nbsp;</a></span>bvm_gl_thread_current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_gl_thread_current = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to the currently executing thread </p>

</div>
</div>
<a id="a08f928ebdecfc4190387445b8642b9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f928ebdecfc4190387445b8642b9cd">&#9670;&nbsp;</a></span>bvm_gl_thread_monitor_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a>* bvm_gl_thread_monitor_list = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to the head of a (cache) list of object monitors </p>

</div>
</div>
<a id="a39d96f81852fa23ce07b3e89a886f7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d96f81852fa23ce07b3e89a886f7f7">&#9670;&nbsp;</a></span>bvm_gl_thread_nondaemon_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_thread_nondaemon_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter of the number of non-daemon threads that have started but not yet terminated </p>

</div>
</div>
<a id="ad7aa9ec2c16c741d31c81f1b486f6b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aa9ec2c16c741d31c81f1b486f6b46">&#9670;&nbsp;</a></span>bvm_gl_thread_runnable_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_gl_thread_runnable_list = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to the head of the list of runnable threads </p>

</div>
</div>
<a id="a9ae9d398762b8469ad48b570f46d5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae9d398762b8469ad48b570f46d5d55">&#9670;&nbsp;</a></span>bvm_gl_thread_timeslice_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_int32_t bvm_gl_thread_timeslice_counter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter that counts down to zero with each bytecode executed to determine when a thread switch takes place. Each thread switch will reset this value to the switched-in thread's timeslice setting. </p>

</div>
</div>
<a id="ae3103edb0d6121eadc5515931f5d888d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3103edb0d6121eadc5515931f5d888d">&#9670;&nbsp;</a></span>bvm_gl_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_gl_threads = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer to the start of the global thread list. This one-way linked list contains all threads and is the root for GC thread scanning. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3b19ecf29356981f494745fbef7e56bf.html">c</a></li><li class="navelem"><a class="el" href="thread_8c.html">thread.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
