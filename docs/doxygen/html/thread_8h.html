<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: src/h/thread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thread_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="thread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bvmthreadobjstruct.html">_bvmthreadobjstruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbvm__find__exception__callback__data.html">bvm_find_exception_callback_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bvmthreadstruct.html">_bvmthreadstruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bvmmonitorstruct.html">_bvmmonitorstruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__bvmstackinfostruct.html">_bvmstackinfostruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3fcda33e411a3f1ca25b862f0206ce71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a3fcda33e411a3f1ca25b862f0206ce71">BVM_THREAD_PRIORITY_MIN</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a3fcda33e411a3f1ca25b862f0206ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28396209378f453f7fc4a84acb94600f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a28396209378f453f7fc4a84acb94600f">BVM_THREAD_PRIORITY_NORM</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a28396209378f453f7fc4a84acb94600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af314868baa09c8696a161619a845138c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af314868baa09c8696a161619a845138c">BVM_THREAD_PRIORITY_MAX</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:af314868baa09c8696a161619a845138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6817b6fc28025e0ebe675a3a4287536d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6817b6fc28025e0ebe675a3a4287536d">BVM_THREAD_KILL_PC</a>&#160;&#160;&#160;((void *)1)</td></tr>
<tr class="separator:a6817b6fc28025e0ebe675a3a4287536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4878a893e32e512f0e411358910eb935"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__bvmthreadobjstruct.html">_bvmthreadobjstruct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4878a893e32e512f0e411358910eb935">bvm_thread_obj_t</a></td></tr>
<tr class="separator:a4878a893e32e512f0e411358910eb935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1334769e61e9c117d2b144fea2aa8184"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structbvm__find__exception__callback__data.html">bvm_find_exception_callback_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1334769e61e9c117d2b144fea2aa8184">bvm_exception_location_data_t</a></td></tr>
<tr class="separator:a1334769e61e9c117d2b144fea2aa8184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341a93b81516e8590ce65b1fc3897a01"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__bvmthreadstruct.html">_bvmthreadstruct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a></td></tr>
<tr class="separator:a341a93b81516e8590ce65b1fc3897a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a8d9d4d723e4265bde2aeab6be5c7e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__bvmmonitorstruct.html">_bvmmonitorstruct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a></td></tr>
<tr class="separator:a42a8d9d4d723e4265bde2aeab6be5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1974d42afcf602c8b592f3da06f0a52b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__bvmstackinfostruct.html">_bvmstackinfostruct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1974d42afcf602c8b592f3da06f0a52b">bvm_stack_frame_info_t</a></td></tr>
<tr class="separator:a1974d42afcf602c8b592f3da06f0a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97a26e64206264ef3acc5113e5ee995"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a>) (<a class="el" href="thread_8h.html#a1974d42afcf602c8b592f3da06f0a52b">bvm_stack_frame_info_t</a> *, void *)</td></tr>
<tr class="separator:ab97a26e64206264ef3acc5113e5ee995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25cfbc88ae7ee2aa1c6eb047c628d1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a25cfbc88ae7ee2aa1c6eb047c628d1dc">bvm_thread_create_vmthread</a> ()</td></tr>
<tr class="separator:a25cfbc88ae7ee2aa1c6eb047c628d1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54cd33811a2766c85a5e73269a5dca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae54cd33811a2766c85a5e73269a5dca2">bvm_thread_start</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *thread_obj, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> push_run_method)</td></tr>
<tr class="separator:ae54cd33811a2766c85a5e73269a5dca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f773397c6468c49947a82359a5a664"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a80f773397c6468c49947a82359a5a664">bvm_next_thread_id</a> ()</td></tr>
<tr class="separator:a80f773397c6468c49947a82359a5a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672b77e9f610add125c63b3740d8b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac672b77e9f610add125c63b3740d8b38">bvm_init_threading</a> ()</td></tr>
<tr class="separator:ac672b77e9f610add125c63b3740d8b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f6cb03f0b95b2d2c4efeb17435c976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae0f6cb03f0b95b2d2c4efeb17435c976">bvm_thread_switch</a> ()</td></tr>
<tr class="separator:ae0f6cb03f0b95b2d2c4efeb17435c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0901e383e5d89ee5c93ce54925169f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac0901e383e5d89ee5c93ce54925169f9">bvm_do_thread_interrupt</a> ()</td></tr>
<tr class="separator:ac0901e383e5d89ee5c93ce54925169f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d4f9d6ef3e02dbe792994fcefaf69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a2b9d4f9d6ef3e02dbe792994fcefaf69">bvm_thread_calc_timeslice</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a2b9d4f9d6ef3e02dbe792994fcefaf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af30841153ca1caf4f5fc3c9c29e77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8af30841153ca1caf4f5fc3c9c29e77a">bvm_thread_monitor_acquire</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj, <a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a8af30841153ca1caf4f5fc3c9c29e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccda5d41ef23475a89a256612250b32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#acccda5d41ef23475a89a256612250b32">bvm_thread_wait</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj, <a class="el" href="structbvm__int64__t.html">bvm_int64_t</a> wait_time)</td></tr>
<tr class="separator:acccda5d41ef23475a89a256612250b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49942720edd9c8bf6a929bbfb58a3266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a49942720edd9c8bf6a929bbfb58a3266">bvm_thread_monitor_release</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj)</td></tr>
<tr class="separator:a49942720edd9c8bf6a929bbfb58a3266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c7d40b005c5da735b3e108cd5ffe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9b9c7d40b005c5da735b3e108cd5ffe3">bvm_thread_notify</a> (<a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *monitor, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> do_all)</td></tr>
<tr class="separator:a9b9c7d40b005c5da735b3e108cd5ffe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa28e69f8b64d7362f1c20ca1323958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afaa28e69f8b64d7362f1c20ca1323958">bvm_thread_interrupt</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:afaa28e69f8b64d7362f1c20ca1323958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae146db66ffdd8c19c10e4987185b8218"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae146db66ffdd8c19c10e4987185b8218">bvm_thread_get_next_id</a> ()</td></tr>
<tr class="separator:ae146db66ffdd8c19c10e4987185b8218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b34cce7ba5d62af00bd135f4bb5ff76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b34cce7ba5d62af00bd135f4bb5ff76">bvm_thread_is_alive</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a6b34cce7ba5d62af00bd135f4bb5ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e264549a30436f137a98e818e6f068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af5e264549a30436f137a98e818e6f068">bvm_thread_sleep</a> (<a class="el" href="structbvm__int64__t.html">bvm_int64_t</a> wait_time)</td></tr>
<tr class="separator:af5e264549a30436f137a98e818e6f068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a9a8c1a03cee49c4c8e3835643c3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac1a9a8c1a03cee49c4c8e3835643c3f8">bvm_thread_terminated_callback</a> (<a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *res1, <a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *res2, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> is_exception, void *data)</td></tr>
<tr class="separator:ac1a9a8c1a03cee49c4c8e3835643c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed37a60e3a76ff5493b1a476f581af01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aed37a60e3a76ff5493b1a476f581af01">bvm_thread_create_stack</a> (bvm_uint32_t height)</td></tr>
<tr class="separator:aed37a60e3a76ff5493b1a476f581af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db6ca91196e32a957a25818f688cef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8db6ca91196e32a957a25818f688cef7">bvm_thread_push_exceptionhandler</a> (<a class="el" href="object_8h.html#a2b4f8c559a1a0a4eeae0bdcec0077e89">bvm_throwable_obj_t</a> *throwable)</td></tr>
<tr class="separator:a8db6ca91196e32a957a25818f688cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce112e2ebc629e24312be75b8fadfbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a3ce112e2ebc629e24312be75b8fadfbd">bvm_thread_store_registers</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a3ce112e2ebc629e24312be75b8fadfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62023494ef3e2590c4499a4c09270451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a62023494ef3e2590c4499a4c09270451">bvm_thread_load_registers</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a62023494ef3e2590c4499a4c09270451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af628995fd6497323f66d1e27917dab22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af628995fd6497323f66d1e27917dab22">get_monitor_for_obj</a> (<a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *obj)</td></tr>
<tr class="separator:af628995fd6497323f66d1e27917dab22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100c13ce5e10a7f949d71101182ae034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a100c13ce5e10a7f949d71101182ae034">bvm_stack_get_depth</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread)</td></tr>
<tr class="separator:a100c13ce5e10a7f949d71101182ae034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9336109962a1de0d1628ab2234b03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aba9336109962a1de0d1628ab2234b03f">bvm_stack_visit</a> (<a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *vmthread, int startframe, int endframe, int *counter, <a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a> callback, void *data)</td></tr>
<tr class="separator:aba9336109962a1de0d1628ab2234b03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3103edb0d6121eadc5515931f5d888d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae3103edb0d6121eadc5515931f5d888d">bvm_gl_threads</a></td></tr>
<tr class="separator:ae3103edb0d6121eadc5515931f5d888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb533cfd34cc4e480e87ce71814df92c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adb533cfd34cc4e480e87ce71814df92c">bvm_gl_thread_current</a></td></tr>
<tr class="separator:adb533cfd34cc4e480e87ce71814df92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d96f81852fa23ce07b3e89a886f7f7"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a39d96f81852fa23ce07b3e89a886f7f7">bvm_gl_thread_nondaemon_count</a></td></tr>
<tr class="separator:a39d96f81852fa23ce07b3e89a886f7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae9d398762b8469ad48b570f46d5d55"><td class="memItemLeft" align="right" valign="top">bvm_int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9ae9d398762b8469ad48b570f46d5d55">bvm_gl_thread_timeslice_counter</a></td></tr>
<tr class="separator:a9ae9d398762b8469ad48b570f46d5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f928ebdecfc4190387445b8642b9cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a08f928ebdecfc4190387445b8642b9cd">bvm_gl_thread_monitor_list</a></td></tr>
<tr class="separator:a08f928ebdecfc4190387445b8642b9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baf57251d155d33bf5c9e5aa0dfd415"><td class="memItemLeft" align="right" valign="top">bvm_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5baf57251d155d33bf5c9e5aa0dfd415">bvm_gl_thread_active_count</a></td></tr>
<tr class="separator:a5baf57251d155d33bf5c9e5aa0dfd415"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Constants/Macros/Functions/Types for thread support.</p>
<dl class="section author"><dt>Author</dt><dd>Greg McCreath </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.0.10 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6817b6fc28025e0ebe675a3a4287536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6817b6fc28025e0ebe675a3a4287536d">&#9670;&nbsp;</a></span>BVM_THREAD_KILL_PC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BVM_THREAD_KILL_PC&#160;&#160;&#160;((void *)1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A special program counter used to help determine when an executing thread has reached the bottom of its execution stack - and thus finished executing. Also used when visiting a stack to know we've hit the bottom. </p>

</div>
</div>
<a id="af314868baa09c8696a161619a845138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af314868baa09c8696a161619a845138c">&#9670;&nbsp;</a></span>BVM_THREAD_PRIORITY_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BVM_THREAD_PRIORITY_MAX&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Java Thread priority MAXIMUM. </p>

</div>
</div>
<a id="a3fcda33e411a3f1ca25b862f0206ce71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcda33e411a3f1ca25b862f0206ce71">&#9670;&nbsp;</a></span>BVM_THREAD_PRIORITY_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BVM_THREAD_PRIORITY_MIN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Java Thread priority MINIMUM. </p>

</div>
</div>
<a id="a28396209378f453f7fc4a84acb94600f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28396209378f453f7fc4a84acb94600f">&#9670;&nbsp;</a></span>BVM_THREAD_PRIORITY_NORM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BVM_THREAD_PRIORITY_NORM&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Java Thread priority NORMAL. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1334769e61e9c117d2b144fea2aa8184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1334769e61e9c117d2b144fea2aa8184">&#9670;&nbsp;</a></span>bvm_exception_location_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structbvm__find__exception__callback__data.html">bvm_find_exception_callback_data</a> <a class="el" href="thread_8h.html#a1334769e61e9c117d2b144fea2aa8184">bvm_exception_location_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42a8d9d4d723e4265bde2aeab6be5c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a8d9d4d723e4265bde2aeab6be5c7e">&#9670;&nbsp;</a></span>bvm_monitor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__bvmmonitorstruct.html">_bvmmonitorstruct</a> <a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A monitor structure for thread lock and wait management. </p>

</div>
</div>
<a id="a1974d42afcf602c8b592f3da06f0a52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1974d42afcf602c8b592f3da06f0a52b">&#9670;&nbsp;</a></span>bvm_stack_frame_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__bvmstackinfostruct.html">_bvmstackinfostruct</a> <a class="el" href="thread_8h.html#a1974d42afcf602c8b592f3da06f0a52b">bvm_stack_frame_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A structure passed to a <a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a> while traversing a thread's stack. The information contained in the struct is relevent to a single stack frame. </p>

</div>
</div>
<a id="ab97a26e64206264ef3acc5113e5ee995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97a26e64206264ef3acc5113e5ee995">&#9670;&nbsp;</a></span>bvm_stack_visit_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>(* bvm_stack_visit_callback_t) (<a class="el" href="thread_8h.html#a1974d42afcf602c8b592f3da06f0a52b">bvm_stack_frame_info_t</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function pointer type for a callback - used during thread stack visitation </p>

</div>
</div>
<a id="a4878a893e32e512f0e411358910eb935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4878a893e32e512f0e411358910eb935">&#9670;&nbsp;</a></span>bvm_thread_obj_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__bvmthreadobjstruct.html">_bvmthreadobjstruct</a> <a class="el" href="thread_8h.html#a4878a893e32e512f0e411358910eb935">bvm_thread_obj_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A Java <code>java.lang.Thread</code> object. </p>

</div>
</div>
<a id="a341a93b81516e8590ce65b1fc3897a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341a93b81516e8590ce65b1fc3897a01">&#9670;&nbsp;</a></span>bvm_vmthread_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__bvmthreadstruct.html">_bvmthreadstruct</a> <a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A VM thread (not a java Thread). This structure is the internal VM structure used to manage a java thread. The Java Thread class is not a final class and can be extended, so this is where we put all our thread management stuff. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac0901e383e5d89ee5c93ce54925169f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0901e383e5d89ee5c93ce54925169f9">&#9670;&nbsp;</a></span>bvm_do_thread_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_do_thread_interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle a pending thread interrupt for the current executing thread. If the thread had a pending exception, that exception is thrown, otherwise <a class="el" href="vm_8h.html#a2f728b9bd377378f1c624d6c30c96942">BVM_ERR_INTERRUPTED_EXCEPTION</a> is thrown.</p>
<p>Before the exception is thrown, the interrupted status of the thread is cleared. </p>

</div>
</div>
<a id="ac672b77e9f610add125c63b3740d8b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac672b77e9f610add125c63b3740d8b38">&#9670;&nbsp;</a></span>bvm_init_threading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_init_threading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs initialisation for threading at VM startup </p>

</div>
</div>
<a id="a80f773397c6468c49947a82359a5a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f773397c6468c49947a82359a5a664">&#9670;&nbsp;</a></span>bvm_next_thread_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_next_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a100c13ce5e10a7f949d71101182ae034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100c13ce5e10a7f949d71101182ae034">&#9670;&nbsp;</a></span>bvm_stack_get_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bvm_stack_get_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the depth of a given thread's stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the depth. </dd></dl>

</div>
</div>
<a id="aba9336109962a1de0d1628ab2234b03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9336109962a1de0d1628ab2234b03f">&#9670;&nbsp;</a></span>bvm_stack_visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_stack_visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startframe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit a given thread's stack from the top to the bottom calling an optional callback handler for each frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the given thread </td></tr>
    <tr><td class="paramname">startframe</td><td>the frame number to start at - the callback will not be invoked until this depth is reached. Pass in zero to start at the very top. </td></tr>
    <tr><td class="paramname">count</td><td>the number of frame to visit after <code>startframe</code> frames have been visited. -1 means go all the way. </td></tr>
    <tr><td class="paramname">depth</td><td>an optional integer pointer that can be used by the calling function to count the total number of frames traversed. So, <code>'startframe=0'</code> and 'length=-1' this will return the depth of the stack. </td></tr>
    <tr><td class="paramname">callback</td><td>an optional <a class="el" href="thread_8h.html#ab97a26e64206264ef3acc5113e5ee995">bvm_stack_visit_callback_t</a> function pointer to call for each visited frame after <code>startframe</code> has been reached. The callback will be passed a bvm_stack_frame_info_t handle describing the frame. </td></tr>
    <tr><td class="paramname">data</td><td>an optional handle to data to pass to the callback when it is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b9d4f9d6ef3e02dbe792994fcefaf69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9d4f9d6ef3e02dbe792994fcefaf69">&#9670;&nbsp;</a></span>bvm_thread_calc_timeslice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_calc_timeslice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate and set the timeslice for a given thread. A thread's timeslice is its priority multiplied by the #thread_default_timeslice var - this gives the number of bytecodes to execute before a thread switch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread to set the timeslice of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed37a60e3a76ff5493b1a476f581af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed37a60e3a76ff5493b1a476f581af01">&#9670;&nbsp;</a></span>bvm_thread_create_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a>* bvm_thread_create_stack </td>
          <td>(</td>
          <td class="paramtype">bvm_uint32_t&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a stack for a thread. The new stack is allocated from the heap and will have its <code>top</code> calculated and its <code>next</code> pointer set to <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>- the height in cells of the new stack (note: NOT in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly created <a class="el" href="frame_8h.html#ad8f1aec298f4d3ca85ed2c3ee1652df0">bvm_stacksegment_t</a>. </dd></dl>

</div>
</div>
<a id="a25cfbc88ae7ee2aa1c6eb047c628d1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cfbc88ae7ee2aa1c6eb047c628d1dc">&#9670;&nbsp;</a></span>bvm_thread_create_vmthread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_thread_create_vmthread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae146db66ffdd8c19c10e4987185b8218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146db66ffdd8c19c10e4987185b8218">&#9670;&nbsp;</a></span>bvm_thread_get_next_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_thread_get_next_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide the next id for a thread. Used for allocation if thread id's at the Java level. </p>

</div>
</div>
<a id="afaa28e69f8b64d7362f1c20ca1323958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa28e69f8b64d7362f1c20ca1323958">&#9670;&nbsp;</a></span>bvm_thread_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt a given thread. If the thread is waiting it is given a 'pending' exception to throw when it wakes and set to wake up immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b34cce7ba5d62af00bd135f4bb5ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b34cce7ba5d62af00bd135f4bb5ff76">&#9670;&nbsp;</a></span>bvm_thread_is_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvm_thread_is_alive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether a given thread is 'alive'. A thread is alive if it is not \ NULL, is not NEW, and is not TERMINATED. </p>

</div>
</div>
<a id="a62023494ef3e2590c4499a4c09270451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62023494ef3e2590c4499a4c09270451">&#9670;&nbsp;</a></span>bvm_thread_load_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_load_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the thread registers to the global registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread with registers to copy to global. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8af30841153ca1caf4f5fc3c9c29e77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af30841153ca1caf4f5fc3c9c29e77a">&#9670;&nbsp;</a></span>bvm_thread_monitor_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a> bvm_thread_monitor_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Have the given thread attempt to acquire the given object's monitor. It the thread can acquire the object's monitor it becomes the owner of that monitor. If it cannot acquire it, the thread becomes blocked and is added to the lock queue of the monitor and will have to re-attempt it at some other time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to lock upon </td></tr>
    <tr><td class="paramname">vmthread</td><td>the thread that is attempt to get the object lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83cae1cc7e51faf7a61d39e7e31a03811117">BVM_TRUE</a> if the monitor was acquired, <a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83ca4f088fab950aba2683ec156bb8d3b7ab">BVM_FALSE</a> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a4c8aca107356ddf11fb56b41e47900e1">BVM_ERR_NULL_POINTER_EXCEPTION</a></td><td>if obj is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49942720edd9c8bf6a929bbfb58a3266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49942720edd9c8bf6a929bbfb58a3266">&#9670;&nbsp;</a></span>bvm_thread_monitor_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_monitor_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a lock on an object. If the lock depth on the object's monitor reaches zero, promote another waiting thread (if any) to be the new owner of the object's monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to release a lock on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a4c8aca107356ddf11fb56b41e47900e1">BVM_ERR_NULL_POINTER_EXCEPTION</a></td><td>if obj is null. </td></tr>
    <tr><td class="paramname"><a class="el" href="vm_8h.html#a9a7dbf96f69a21759af02cffdaf08cdf">BVM_ERR_ILLEGAL_MONITOR_STATE_EXCEPTION</a></td><td>if the monitor's owner thread is not the current thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9c7d40b005c5da735b3e108cd5ffe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c7d40b005c5da735b3e108cd5ffe3">&#9670;&nbsp;</a></span>bvm_thread_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a> *&#160;</td>
          <td class="paramname"><em>monitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>do_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notifies one or all threads waiting on an object's monitor. Performs the equivalent of the java <code>notify()</code> and <code>notifyAll()</code> logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object that threads may be waiting on </td></tr>
    <tr><td class="paramname">do_all</td><td>if <code>BVM_TRUE</code>, notify all waiting threads, if <code>BVM_FALSE</code>, notify just a single waiting thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a9d5c9887acc25ad404fc4c22799546b6">bvm_vmthread_t::BVM_THREAD_STATUS_WAITING</a> and <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a47d2a12dff7c62354ca5c7732a2c326f">bvm_vmthread_t::BVM_THREAD_STATUS_TIMED_WAITING</a> states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db6ca91196e32a957a25818f688cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db6ca91196e32a957a25818f688cef7">&#9670;&nbsp;</a></span>bvm_thread_push_exceptionhandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_push_exceptionhandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="object_8h.html#a2b4f8c559a1a0a4eeae0bdcec0077e89">bvm_throwable_obj_t</a> *&#160;</td>
          <td class="paramname"><em>throwable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push the java.lang.Thread::dispatchUncaughtException() method for the current thread onto the stack.</p>
<p>This method is called when an uncaught exception has been encountered for a thread - that is, exception handling went all the way to the bottom of the stack and did not find a handler.</p>
<p>This enables Java developers to pick up the mess.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">throwable</td><td>the uncaught exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5e264549a30436f137a98e818e6f068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e264549a30436f137a98e818e6f068">&#9670;&nbsp;</a></span>bvm_thread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbvm__int64__t.html">bvm_int64_t</a>&#160;</td>
          <td class="paramname"><em>sleep_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cause the current thread to sleep a given number of milliseconds.</p>
<p>After this function, the thread will be <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a> with a <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a47d2a12dff7c62354ca5c7732a2c326f">bvm_vmthread_t::BVM_THREAD_STATUS_TIMED_WAITING</a> modifier and will be in the timed-callback list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleep_time</td><td>the time to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae54cd33811a2766c85a5e73269a5dca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54cd33811a2766c85a5e73269a5dca2">&#9670;&nbsp;</a></span>bvm_thread_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>push_run_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a new VM thread, set it up to run the correct thread <code>run()</code> method and attempt to get it started.</p>
<p>Two frames are pushed onto the stack. The first is a callback wedge that, when reached, signals that the thread has finished execution, and the second is (optionally) the java <code>run()</code> method to execute.</p>
<p>If the <code>run()</code> method is not synchronised, the thread status is set momentarily to <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a60b8e46a988c7af18871305f7b799685">bvm_vmthread_t::BVM_THREAD_STATUS_BLOCKED</a>, and then usual blocked-thread resumption code kicks in to unblock it and add it to the runnable list (all using #thread_resume).</p>
<p>If the run method is synchronised, an attempt is made to gain the monitor for the thread object. If it can be acquired, the same process for an synchronised \ run() method happens and the thread ends up being runnable and in the runnable list. If the monitor cannot be acquired, the thread enters a blocked state and waits on the monitor like any other blocked thread waiting on a monitor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>- the thread to start </td></tr>
    <tr><td class="paramname">push_run_method</td><td>- if BVM_FALSE, do thread startup but do not push the 'run' method as described above - just the callback wedge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600a322bf0d1c86150e818bb3e362ce0b360">bvm_vmthread_t::BVM_THREAD_STATUS_NEW</a> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce112e2ebc629e24312be75b8fadfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce112e2ebc629e24312be75b8fadfbd">&#9670;&nbsp;</a></span>bvm_thread_store_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_store_registers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a> *&#160;</td>
          <td class="paramname"><em>vmthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the global registers to the thread registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmthread</td><td>the thread to copy the global registers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f6cb03f0b95b2d2c4efeb17435c976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f6cb03f0b95b2d2c4efeb17435c976">&#9670;&nbsp;</a></span>bvm_thread_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_switch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch from the current thread to the next runnable thread.</p>
<p>The timeslice counter will be set to the timeslice for the selected thread. If the current thread is the only runnable thread it will remain current and, of course, the thread timeslice counter is reset.</p>
<p>Each time this function is called the timed callback list is scanned (if there is anything in it).</p>
<p>TODO: A more efficient means of checking the callback list is required. Maybe every 'n' times this function is called might be a simple way. A better way would be to only check it when sure there is something to resume - like doing a smart thing when adding something to the list. </p>

</div>
</div>
<a id="ac1a9a8c1a03cee49c4c8e3835643c3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a9a8c1a03cee49c4c8e3835643c3f8">&#9670;&nbsp;</a></span>bvm_thread_terminated_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a>* bvm_thread_terminated_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td>
          <td class="paramname"><em>res1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a55eab28c2de486e0b3d7eb516cdfb653">bvm_cell_t</a> *&#160;</td>
          <td class="paramname"><em>res2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bvm_8h.html#a2284c1e362982e74ed5657631f5ae83c">bvm_bool_t</a>&#160;</td>
          <td class="paramname"><em>is_exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The callback from the interp loop when a thread reaches the bottom of its execution stack. Will cause a thread switch to the next runnable thread. The exited thread has it status set to <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600aaede24a699c6f460e946b4d32608182d">bvm_vmthread_t::BVM_THREAD_STATUS_TERMINATED</a> and its stack memory freed. Any other thread waiting on this thread's monitor are notified.</p>
<p>Params unused in termination callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res1</td><td></td></tr>
    <tr><td class="paramname">res2</td><td></td></tr>
    <tr><td class="paramname">is_exception</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="vm_8h.html#abed46f0200c4ce46c3feadbb888d560d">BVM_ERR_ILLEGAL_THREAD_STATE_EXCEPTION</a></td><td>if the thread is not in the <a class="el" href="struct__bvmthreadstruct.html#abed82baf7f470b522273a3e37c24c600ada00aa4e7a1bbb7414269e83f67240eb">bvm_vmthread_t::BVM_THREAD_STATUS_RUNNABLE</a> state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acccda5d41ef23475a89a256612250b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccda5d41ef23475a89a256612250b32">&#9670;&nbsp;</a></span>bvm_thread_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bvm_thread_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbvm__int64__t.html">bvm_int64_t</a>&#160;</td>
          <td class="paramname"><em>wait_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the current thread to wait on another object. If a wait time is specified, the thread will be added to the timed-callbacks list and will try to acquire the monitor of the given object when it wakes.</p>
<p>If no wait_time is given, the thread is added to the given object's monitor wait queue.</p>
<p>In all cases, the current thread will become blocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object to wait on. </td></tr>
    <tr><td class="paramname">wait_time</td><td>the time in milliseconds to wait for it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af628995fd6497323f66d1e27917dab22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af628995fd6497323f66d1e27917dab22">&#9670;&nbsp;</a></span>get_monitor_for_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a>* get_monitor_for_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="clazz_8h.html#a39dbc39868649a19e787acfc19537cdc">bvm_obj_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan the monitor list for a matching object. If none found, returns <code>NULL</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bvm_monitor_t for the given object, or <code>NULL</code> if not found. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5baf57251d155d33bf5c9e5aa0dfd415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baf57251d155d33bf5c9e5aa0dfd415">&#9670;&nbsp;</a></span>bvm_gl_thread_active_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_thread_active_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter of all the active (daemon and non-daemon) threads. Where active = started and not yet terminated </p>

</div>
</div>
<a id="adb533cfd34cc4e480e87ce71814df92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb533cfd34cc4e480e87ce71814df92c">&#9670;&nbsp;</a></span>bvm_gl_thread_current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_gl_thread_current</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to the currently executing thread </p>

</div>
</div>
<a id="a08f928ebdecfc4190387445b8642b9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f928ebdecfc4190387445b8642b9cd">&#9670;&nbsp;</a></span>bvm_gl_thread_monitor_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a42a8d9d4d723e4265bde2aeab6be5c7e">bvm_monitor_t</a>* bvm_gl_thread_monitor_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to the head of a (cache) list of object monitors </p>

</div>
</div>
<a id="a39d96f81852fa23ce07b3e89a886f7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d96f81852fa23ce07b3e89a886f7f7">&#9670;&nbsp;</a></span>bvm_gl_thread_nondaemon_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_uint32_t bvm_gl_thread_nondaemon_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter of the number of non-daemon threads that have started but not yet terminated </p>

</div>
</div>
<a id="a9ae9d398762b8469ad48b570f46d5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae9d398762b8469ad48b570f46d5d55">&#9670;&nbsp;</a></span>bvm_gl_thread_timeslice_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bvm_int32_t bvm_gl_thread_timeslice_counter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter that counts down to zero with each bytecode executed to determine when a thread switch takes place. Each thread switch will reset this value to the switched-in thread's timeslice setting. </p>

</div>
</div>
<a id="ae3103edb0d6121eadc5515931f5d888d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3103edb0d6121eadc5515931f5d888d">&#9670;&nbsp;</a></span>bvm_gl_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="thread_8h.html#a341a93b81516e8590ce65b1fc3897a01">bvm_vmthread_t</a>* bvm_gl_threads</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer to the start of the global thread list. This one-way linked list contains all threads and is the root for GC thread scanning. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_91e09e7569ccd19553b6fd3d442a4b1c.html">h</a></li><li class="navelem"><a class="el" href="thread_8h.html">thread.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
