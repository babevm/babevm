<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Babe VM: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Babe VM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Babe VM Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Babe Virtual Machine.</p>
<h1><a class="anchor" id="vm-welcome"></a>
Welcome to the Machine.</h1>
<p>First, Oracle and Java are registered trademarks of Oracle and/or its affiliates. This VM has no association with Oracle and does not claim to be Java or 'Java compatible'.</p>
<p>The Babe Virtual Machine (aka BVM) is an implementation of the Oracle Java Virtual Machine Specification (JVMS) 1.6. This VM executes Java bytecode according to the JVMS and has a supporting runtime support library of classes to support the operational VM.</p>
<p>The BVM is intended for small environments that require a small and fast means of running Java bytecode - albeit without skimping on the good bits.</p>
<p>The overall objectives of the BVM implementation are to provide a fast, small, full-featured Java Virtual Machine and associated core classes.</p>
<p>The target environment is small secure devices like a payments terminal. Indeed, many of the decisions regarding the VM have taken this environment into account - for example - in the name of closing security doors, class files are not read at runtime by java classes and handed to the VM. In this case, the VM handles all class file reading so no developer can create or load classes at runtime that are not deployed with the application. Reflection is not available. Additionally, the notion of runtime protection of code is implemented.</p>
<p>An overview of the features of the Babe VM.</p>
<ul>
<li>Java 6. Runs code compiled with a Java 6 compiler, or a compiler configured to produce Java 6 classes. </li>
<li>32 bit and 64 bit. </li>
<li>small - about 150k or so. </li>
<li>Every JVMS opcode is implemented. Doubles, longs, thread monitors etc. </li>
<li>threads - a complete (green) thread implementation with all locking / synchronisation. </li>
<li>memory efficient - it is used very sparingly ... </li>
<li>performant - it ain't a slug. </li>
<li>portable - intended to be portable across OSs and architectures. It is developed in ANSI C (90) with very few standard lib functions used. </li>
<li>garbage collected - a full GC implementation (except for Java finalizers). Collection of Class objects and Classloader objects is supported. </li>
<li>unicode - from the ground up. </li>
<li>longs - Native 64 bits longs are supported - even on 32 bit platforms. Java longs can be emulated on small architectures that do not support 64 bit integers. </li>
<li>stack traces - Familiar feeling stack-traces are implemented. </li>
<li>Native Interface - a 'JNI' implementation similar to that of the Java Native Interface albeit particular to this VM. </li>
<li>jars - support for reading class files from jars. </li>
<li>classLoaders - loaded java classes are namespaced by their class loader as per the JVMS. </li>
<li>unified memory management - the running VM uses the same memory primitives as the Java bytecode and also the same Garbage Collector. The 'C' VM is garbage collected just like Java is (and at the same time). The memory allocator is a "coallescing best fit" algorithm. </li>
<li>intern strings - supported. </li>
<li>class/member access visibility - class and member visibility semantics are fully implemented (some tiny VMs treat everything as 'public'). </li>
<li>class assignment - all JVMS class assignment rules are implemented - some small VMs skip here </li>
<li>limited class verification implemented - focusing around language security, not class file correctness. </li>
<li>dynamic thread stacks - thread stacks start as small as they can be and grow and shrink as required. A thread stack can be as little as 128 bytes and still be useful. </li>
<li>exceptions - full support for try/catch/finally and thread uncaught exception handlers. VM exceptions and bytecode exceptions use the same handling code. </li>
<li>weakReferences - support as per CLDC 1.1 </li>
<li>'direct threading' - when using GCC, the interpreter switch use the GCC 'labels as values' to speed up opcode dispatch.</li>
</ul>
<p>Last but not least is that the Babe VM also implements remote debugging and so it may be debugged using a standard development IDE like Intellij or VSCode or Eclipse. Remote debugging is by way of a Java Debug Wire Protocol (JDWP) implementation. The JDWP is a standard part of the Java Platform Debug Architecture (JPDA). This VM implements all sensible parts of it for a small VM.</p>
<p>Some noteable Limitations:</p>
<ul>
<li>16mb heap limit max. The memory allocator uses 24 bits to express the size of a memory chunk. Each memory chunk has a single 32bit header of which 24bits represent the size of the memory chunk. Given the target environment, it is rare that this VM will have 16m allocated to it. </li>
<li>class loaders are not responsible for reading class file bytes. They serve primarily as a namespace for loaded classes and thus 'application' separation. All class file reading is performed by the VM. </li>
<li>class loading is restricted to files that can be found either on the class path or are contained within a jar file on the class path. Jar files must end with a lowercase ".jar". </li>
<li>the heap does not grow or shrink - the heap size is declared on startup and its size remains constant.</li>
</ul>
<h1><a class="anchor" id="requirements"></a>
Requirements</h1>
<p>The Babe VM has the following requirements:</p>
<ul>
<li>the OS platform must be able to allocate dynamic memory. </li>
<li>a file system of some sort must be available - supports an ANSI C file interface, but others can be implemented. </li>
<li>the platform C compiler/libraries must support the ANSI C <code>setjmp()</code> and <code>longjmp()</code> functions. </li>
<li>at least 128k of memory available for the running VM heap. It is certainly possible to run programs in less than this, but they will be (no doubt) trivial. Memory usage is larger for 64 bit. </li>
<li>a 32 bit integer type. Signed and unsigned. For 64 bit same but with more bits ... </li>
<li>a clock preferably one that gives millisecond timing. The ability to (somehow) calculate the number of milliseconds since Jan 1 1970 must be available.</li>
</ul>
<h1><a class="anchor" id="vm-architecture-overview"></a>
Architecture Overview</h1>
<p>The VM is, like all other Javas VMs, a 'Java bytecode interpreter'. Given the 'small device' target environment, it has had to strike a balance between speed, size, and memory usage, and complexity to achieve what it does. A key design goal was to keep the VM and core classes to about 100k each and yet provide as complete an implementation of the JVMS as possible . Ultimately, software this small is a collection of compromises made to balance each of the competing concerns above. There is no point in creating a platform that is very small, but very slow, or hyper-quick, but too large, or will not run on a 'standard' machine. Also, there is no point is creating a system so complex and clever that no-one will ever be able to understand the code nor help maintain it.</p>
<p>To this end, the key overriding design goal of this VM is simplicity. Simple is small, often quick, and easy to understand. Having said that, a VM is quite often not a simple piece of software. In this implementation there a few areas that seem complex, but hopefully, the unit documentation provides enough detail for a developer to understand the mechanisms and the reasoning behind them.</p>
<p>In point form, what follows is a small discussion on a number of the key architectural aspects of the Babe VM.</p>
<h2><a class="anchor" id="vm-intro-memory"></a>
Memory management.</h2>
<p>The VM performs all its own memory management, including garbage collection. At startup, the VM heap is allocated from the OS and it is never expanded nor shrunk during execution. The memory allocator (found in <a class="el" href="heap_8c.html">heap.c</a>) is meant for managing a small linear address space. It assumes that issues such as locality-of-reference or paging are not actually present (as is often the case in smaller platforms).</p>
<p>Once allocated, memory does not move - it is not compacted or reshuffled. This means all memory references can be direct references and performance does not suffer from pointer indirections. The allocator algorithm is coalescing. That is, adjacent free memory blocks are coalesced into larger ones. In this manner, fragmentation is greatly minimised.</p>
<p>The memory allocator is shared between the VM, for any of its operations, and Java. Therefore all internal 'C' memory usage and Java memory usage is unified. The memory used by the VM is garbage collected in the same way the memory the Java programs it runs is. In this sense, the VM memory usage is "unified".</p>
<p>The VM allocator imposes a 16mb heap maximum. This is to cut down on the overhead associated with tracking memory allocations, including Java objects. The heap allocator has an overhead of 4 bytes per memory allocation, and 24 of those 32 bits is used to specify the size of an allocation. 2^24 is 16mb.</p>
<h2><a class="anchor" id="vm-intro-bvm_gc"></a>
Garbage Collection.</h2>
<p>The garbage collector (GC) is a mark-and-sweep collector. Its role is to determine what memory is no longer used and return it to the VM heap. The GC uses a tricolour scheme to mark references grey while marking, then black. Unmarked references are left as white and freed. When memory is requested from the allocator, a 'type' is specified. The type is used by the garbage collector to determine how to scan the memory for other memory references. Actually, the GC mechanisms are pretty straight forward. More interesting is how the GC determines its roots for reference marking.</p>
<p>Besides each thread's method call stack (which are 'root' sources of references) the VM maintains two stacks used for 'permanent' and 'transient' root references. During the GC mark phase, each of these stacks is traversed and each reference they contain is scanned and marked. The permanent root stack contains memory references that are unchanging during the lifetime of the VM - like some pre-built structures the VM uses during execution.</p>
<p>The transient root stack contains transient references that are momentary in existence. A transient reference is valid during a block of code called a 'transient block'. After a transient code block has exited, any transient references created within it are no longer considered as 'roots' and are eligible for GC. Thus, the size of the transient stack grows and shrinks as these transient blocks are entered and exited.</p>
<p>WeakReference objects are supported as per the CLDC 1.1 specification.</p>
<p>The size of the permanent and transient stacks can be set at VM startup.</p>
<h2><a class="anchor" id="vm-intro-trycatch"></a>
Try / Catch and Exceptions</h2>
<p>Augmenting the usage of transient blocks is a 'try/catch' mechanism with exceptions. In VM C code, exceptions are thrown in much the same way as java exceptions are. They can also be caught in VM code, or in Java code. The exceptions thrown in the VM code are actually Java exception objects.</p>
<p>An exception thrown in C will propagate up to the Java code level if it is uncaught in the VM. In this way, the VM can treat its own errors as Java errors and they will be presented to the Java layer if the C code does not deal with them. For example, when executing (say) the bytecode to put a value into an array index, if the array object is <code>NULL</code> the VM code can throw a Java <code>NullPointerException</code> and, if uncaught in the VM, that exception will be thrown at the java layer as same exception.</p>
<p>Using a try / catch mechanism at the VM level has obviated the need for the usual development pattern in C of using return codes to indicate errors and using pointer arguments to pass back return values. In this VM, generally, functions return properly typed meaningful values, and not return codes. If something goes wrong, an exception is thrown. It is simple (ish) in its implementation and works surprisingly well. It does mean the compiler and target environment must support the ANSI C <code>setjmp()</code> and <code>longjmp()</code> functions.</p>
<p>Usually, one of the key reasons for using the traditional 'functions return codes for errors' development pattern is not to alter the program flow unexpectedly and thus give the developer an opportunity to 'clean up' when things go wrong. 'Clean up' normally means 'memory clean up' to avoid leaks. With this VM, the memory cleanup is automatic so there are no leaks.</p>
<p>How? When a exception is thrown all transient references since the last 'try' are discarded and become eligible for garbage collection. In reality, a try / catch is like a transient block.</p>
<p>What this ultimately adds up to is a much less code for handling errors conditions. The VM C code is written in such a manner as to assume that everything will always work as expected, and leaves it to the exception handing mechanism to deal with problems. This would not have been possible without the VM being garbage collected like Java and the use of 'transient references'.</p>
<h2><a class="anchor" id="vm-intro-interp"></a>
The Interpreter</h2>
<p>The interpreter is a classic large switch statement. When the VM starts it performs its initialisation, finds the starting Java 'main' method and then launches into the 'interp' loop .... and there is stays until the VM exits. All threads share this one running loop and are swapped in and out.</p>
<p>Some non-standard Java opcodes exist within the 'switch'. Mostly, these are 'fast' implementations of a number of standard opcodes. Often, when a given opcode within a given method is executed, a number of checks are performed and pointers are resolved and so on. These are not required to be re-checked or re-resolved on subsequent executions of that particular bytecode. In this case, the VM substitutes the bytecode for another 'fast' version of the same functionality. The next time the bytecode is to be executed, the faster version is executed instead.</p>
<p>If the VM is compiled with debugger support, this 'fast' bytecode substitution does not take place. The debugger facilities needs to perform its own bytecode substitution for 'breakpoint'.</p>
<h2><a class="anchor" id="vm-intro-threads"></a>
Threads</h2>
<p>The VM fully implements java threading. Threading here is independent from any underlying threading services the platform operating system may provide. This is to keep things as simple and portable as possible and provide threads to Java applications running on platforms that do not have threads. Implementing threads above the OS (or 'green' threads as they are usually called) does provide consistent portability, however this comes at some internal complexity - especially around the VM method call stack, and especially when debugging - debuggers always suspend and resume threads. In a 'green' thread implementation this can cause a few thread 'gymnastics' occasionally.</p>
<p>Greens thread do not permit calling Java methods from the VM C code. This creates some complications at times when the VM must* call Java methods - like when a thread <code>run()</code> method is called, or <code>Class.newInstance()</code> must have an object constructor called and so on. Hopefully the documentation at each point helps the developer to understand the intention and the mechanism.</p>
<p>The limitation that VM code cannot call a Java method also means that a full Java Native Interface (JNI) implementation is not possible.</p>
<p>Although complete, the VM threading implementation is reasonably simple. The scheduling algorithm is based on each thread having a number of bytecodes to execute before a thread 'context switch' takes place. The number of bytecodes each thread executes before being swapped is related to the thread's priority. All very simple.</p>
<p>All threads have their own call stacks but share the one interpreter loop. Threads stacks start small then grow and shrink as required. That is, if additional stack space is needed it will be allocated it from the shared heap and, when no longer required, given back to the heap. A thread call stack is a linked list of stack 'segments'.</p>
<h2><a class="anchor" id="vm-intro-pool"></a>
Pooling Resources</h2>
<p>A number of 'pools' exist within the VM. A pool is actually a cache in the form of a hash map structure. There is no generic hash map structure - each pooled 'thing' has a 'next' member of its structure to help with pooling. This makes pooling much smaller and much faster at the possible expense of a some code redundancy here and there (but not much). The VM pools classes, strings, and native methods definitions among other things.</p>
<h2><a class="anchor" id="vm-intro-classLoading"></a>
Class Loading</h2>
<p>In Java, a class is namespaced by the ClassLoader object that loaded it. Two identically named classes loaded with different loaders are considered by the VM to be different classes. This can be used to prevent class naming collisions between two running applications. Just like Java SE, classloaders here form a hierarchy, and each time a class is to be loaded the parentage gets first go.</p>
<p>Babe VM Classloaders use a classpath. Classpaths may include '.jar' archive files.</p>
<p>There are two distinct VM classpaths. One is the 'boot' classpath. The 'bootstrap' class loader is responsible for loading the core 'java' and VM runtime classes. Classes loaded on the boot classpath are trusted.</p>
<p>The second classpath is the 'user' classpath. This is the classpath for application and framework classes. No class on the user classpath may belong to a package that begins with 'java/' or 'babe/'. This ensures that no application or framework class can pretend to be a system class.</p>
<p>Unlike Java SE class loading, a class loader here does not have the capability of loading a stream of bytes and handing that off to the VM for class loading. In this VM, only the VM itself can load class files. The classloaders serve as a means of specifying a classpath for the VM to search on - and as a container for a list of Class objects it has loaded - to stop them being GC'd. We get the benefit of classloader namespacing, but the security of knowing that developers cannot manipulate (possibly certified) class files on-the-fly.</p>
<p>Like Java SE, classloaders also serve as a mean to stop Class objects being GC'd. According to the JVMS, classes may be unloaded when their classloader is unreachable and is eligible for GC. This is exactly how it happen in this VM. Classes and their associated internals class structures may be GC'd, but only in those prescribed circumstances. This gives the VM the ability to completely unload an 'application' and all its classes and free up the memory for other 'applications'.</p>
<p>The JVMS describes two types of relationships a classloader may have with a class. A classloader may be the 'defining' loader for a given class (meaning it was the one that found the class in its classpath and actually loaded it), and/or it may be an 'initiating' classloader for a class (meaning it either loaded it, or attempted to load it but could not so it delegated it). This VM does not track the 'initiating' relationship - only the defining class loader relationship is maintained.</p>
<h2><a class="anchor" id="vm-intro-jarfiles"></a>
Jar Files.</h2>
<p>Class loading from jar files is supported. The classloader's classpath may include files that end in lowercase '.jar' (case sensitive). The inflate code is very small and (no doubt) not as efficient as some implementations, but it adds only 2.5k to the VM. This is less than 10% of the size of most standard inflate libs such as zlib.</p>
<p>The VM implements a very small directory cache for each jar it opens. The entire directory is not cached, just some small parts of it that help the VM to locate files more quickly, for example, rather than cache file names in the jar, just the hash of the name is, and an offset into the directory. In that way when looking up an entry only the cache may be scanned for matching hashes, and on a match, further inspection to see it if really is the requested file. If it is, the directory offset gives where to get the rest of the file information.</p>
<p>Jar files are not closed by the VM, once on the classpath, they are open for the duration of the running VM, and their cached directories are also.</p>
<h2><a class="anchor" id="vm-intro-longs"></a>
Longs</h2>
<p>The 64 bit java 'long' primitive type is supported both in emulated form as well as native form. That is, if the target platform has a native 64 bit integer type then Babe can use it. Otherwise, 64 bit integer support is emulated using two 32 bit integers and 'arbitrary precision' mathematics.</p>
<p>When using float support, there is no choice - native 64bit long usage is a prerequisite.</p>
<h2><a class="anchor" id="nativeInterface"></a>
The Native Interface</h2>
<p>A native interface (NI) API is provided that is modelled on the java Native Interface (JNI). I say 'modelled' because it is not possible to provide a complete JNI implementation on such a small VM. The JNI <em>assumes</em> dynamically loadable libraries such as DLLs on windows or shared objects on Linux. The Babe VM assumes these facilities are not present and that all libraries are statically linked.</p>
<p>Additionally, the greens threads implementation means that java methods cannot be called from C code. This precludes a portion of the JNI specification. However, having said that, the Babe native interface provides <em>most</em> of the JNI API. Indeed, the method comments on the NI ape the specification.</p>
<p>The Babe NI has no notion of an 'environment' like the JNI does. In JNI the 'environment' is passed to all functions - it is a C interface struct containing method pointers. The Babe NI has no requirement for such an interface. Additionally, the Babe NI provides no facilities for 'global' memory allocations.</p>
<p>Like the JNI, and unlike the rest of the Babe VM, Babe NI functions have return values and do not throw exceptions. Error codes must be checked and exceptions must be handled manually. This is a break from Babe VM convention, but it is as per the JNI specification.</p>
<h2><a class="anchor" id="vm-intro-debugger"></a>
Debugging</h2>
<p>An implementation of the Java Debug Wire Protocol is included. Almost all standard facilities are there, as well as some optional ones (like inspecting thread monitors and getting raw bytecodes). Including JDWP means standard debuggers such as Intellij, VSCode or Eclipse can attach to a running Babe VM instance (or vice-versa) to perform source level debugging with all breakpoint and variable inspection facilities. Additionally, initial support for JSR045 "Debugging Other Languages" is included, so that a debugger can debug bytecodes / source written in a non-Java language.</p>
<p>The JDWP debigger-support code can be optionally compiled in/out on the VM. Depending on the compiler, the size of this code may vary but the debugger support code is fairly substantial. Consider excluding it for production builds - the VM will be smaller and will run faster - some performance optimisations are not possible when debugger code is included.</p>
<p>The transport layer of the debugger support is abstracted so that any transport may be implemented. A sockets implementation is provided, but (in theory) the transport could be anything from shared-memory to dial-up. Both client and server modes are supported by the transport abstraction meaning that the VM (in client mode) can 'attach' to a running debugger that is waiting for a incoming connection, or (in server mode) listen for a debugger to connect to it. The attach and listen addresses can be set using command line arguments.</p>
<p>The debugger code does complicate things sometimes. In a VM with native threads the interaction with a debugger might be simpler in the sense when the debugger suspends a thread it really is suspended. The whole running java/C thread is suspended. With green threads it is a little more complex and sometimes the VM has to inspect a thread's 'suspend' status after an interaction with the debugger to determine what it should do next. This can cause some complexity, but hopefully the code comments describe what is going on well enough.</p>
<p>Developers should note that debuggers interact really quite a lot with running VMs. Lots of small packets go between debugger and VM - often multiple times for exactly the same thing. Before attempting to provide 'on-platform' debugger communications it may be worth considering whether 'off-platform' debugging provides what is needed.</p>
<p>Refer : <a class="el" href="debugger_8c.html#debug-ov">Debugging Overview</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
